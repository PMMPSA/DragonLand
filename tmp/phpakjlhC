<?php
namespace EssentialsPE;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use EssentialsPE\Commands\AFK;
use EssentialsPE\Commands\Antioch;
use EssentialsPE\Commands\Back;
use EssentialsPE\Commands\BreakCommand;
use EssentialsPE\Commands\Broadcast;
use EssentialsPE\Commands\Burn;
use EssentialsPE\Commands\ClearInventory;
use EssentialsPE\Commands\Compass;
use EssentialsPE\Commands\Condense;
use EssentialsPE\Commands\Depth;
use EssentialsPE\Commands\Economy\Balance;
use EssentialsPE\Commands\Economy\Eco;
use EssentialsPE\Commands\Economy\Pay;
use EssentialsPE\Commands\Economy\Sell;
use EssentialsPE\Commands\Economy\SetWorth;
use EssentialsPE\Commands\Economy\Worth;
use EssentialsPE\Commands\Economy\BalanceTop;
use EssentialsPE\Commands\EssentialsPE;
use EssentialsPE\Commands\Feed;
use EssentialsPE\Commands\Extinguish;
use EssentialsPE\Commands\Fly;
use EssentialsPE\Commands\GetPos;
use EssentialsPE\Commands\God;
use EssentialsPE\Commands\Heal;
use EssentialsPE\Commands\Home\DelHome;
use EssentialsPE\Commands\Home\Home;
use EssentialsPE\Commands\Home\SetHome;
use EssentialsPE\Commands\ItemCommand;
use EssentialsPE\Commands\ItemDB;
use EssentialsPE\Commands\Jump;
use EssentialsPE\Commands\KickAll;
use EssentialsPE\Commands\Kit;
use EssentialsPE\Commands\Lightning;
use EssentialsPE\Commands\More;
use EssentialsPE\Commands\Mute;
use EssentialsPE\Commands\Near;
use EssentialsPE\Commands\Nick;
use EssentialsPE\Commands\Nuke;
use EssentialsPE\Commands\Override\Gamemode;
use EssentialsPE\Commands\Override\Kill;
use EssentialsPE\Commands\Override\Msg;
use EssentialsPE\Commands\Ping;
use EssentialsPE\Commands\PowerTool\PowerTool;
use EssentialsPE\Commands\PowerTool\PowerToolToggle;
use EssentialsPE\Commands\PTime;
use EssentialsPE\Commands\PvP;
use EssentialsPE\Commands\RealName;
use EssentialsPE\Commands\Repair;
use EssentialsPE\Commands\Reply;
use EssentialsPE\Commands\Seen;
use EssentialsPE\Commands\SetSpawn;
use EssentialsPE\Commands\Spawn;
use EssentialsPE\Commands\Sudo;
use EssentialsPE\Commands\Suicide;
use EssentialsPE\Commands\Teleport\TPA;
use EssentialsPE\Commands\Teleport\TPAccept;
use EssentialsPE\Commands\Teleport\TPAHere;
use EssentialsPE\Commands\Teleport\TPAll;
use EssentialsPE\Commands\Teleport\TPDeny;
use EssentialsPE\Commands\Teleport\TPHere;
use EssentialsPE\Commands\TempBan;
use EssentialsPE\Commands\Top;
use EssentialsPE\Commands\Unlimited;
use EssentialsPE\Commands\Vanish;
use EssentialsPE\Commands\Warp\DelWarp;
use EssentialsPE\Commands\Warp\Setwarp;
use EssentialsPE\Commands\Warp\Warp;
use EssentialsPE\Commands\World;
use EssentialsPE\EventHandlers\OtherEvents;
use EssentialsPE\EventHandlers\PlayerEvents;
use EssentialsPE\EventHandlers\SignEvents;
use EssentialsPE\Events\CreateAPIEvent;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\TextFormat;

class Loader extends PluginBase{
    /** @var BaseAPI */
    private $api;

    public function onEnable(){
        if($this->getConfig()->get("enable") === false) {
           $this->setEnabled(false);
        }
        // Before anything else...
        $this->checkConfig();

        // Custom API Setup :3
        $this->getServer()->getPluginManager()->callEvent($ev = new CreateAPIEvent($this, BaseAPI::class));
        $class = $ev->getClass();
        $this->api = new $class($this);

        // Other startup code...
        if(!is_dir($this->getDataFolder())){
            mkdir($this->getDataFolder());
        }
        
	$this->getLogger()->info(TextFormat::YELLOW . "Loading...");
        $this->registerEvents();
        $this->registerCommands();
        if(count($p = $this->getServer()->getOnlinePlayers()) > 0){
            $this->getAPI()->createSession($p);
        }
        if($this->getAPI()->isUpdaterEnabled()){
            $this->getAPI()->fetchEssentialsPEUpdate(false);
        }
        $this->getAPI()->scheduleAutoAFKSetter();
    }

    public function onDisable(){
        if(count($l = $this->getServer()->getOnlinePlayers()) > 0){
            $this->getAPI()->removeSession($l);
        }
        $this->getAPI()->__destruct();
    }

    /**
     * Function to register all the Event Handlers that EssentialsPE provide
     */
    public function registerEvents(){
        $this->getServer()->getPluginManager()->registerEvents(new OtherEvents($this->getAPI()), $this);
        $this->getServer()->getPluginManager()->registerEvents(new PlayerEvents($this->getAPI()), $this);
        $this->getServer()->getPluginManager()->registerEvents(new SignEvents($this->getAPI()), $this);
    }

    /**
     * Function to register all EssentialsPE's commands...
     * And to override some default ones
     */
    private function registerCommands(){
        $commands = [
            new AFK($this->getAPI()),
            new Antioch($this->getAPI()),
            new Back($this->getAPI()),
            //new BigTreeCommand($this->getAPI()), TODO
            new BreakCommand($this->getAPI()),
            new Broadcast($this->getAPI()),
            new Burn($this->getAPI()),
            new ClearInventory($this->getAPI()),
            new Compass($this->getAPI()),
            new Condense($this->getAPI()),
            new Depth($this->getAPI()),
            new EssentialsPE($this->getAPI()),
            new Extinguish($this->getAPI()),
            new Fly($this->getAPI()),
            new GetPos($this->getAPI()),
            new God($this->getAPI()),
            //new Hat($this->getAPI()), TODO: Implement when MCPE implements "Block-Hat rendering"
            new Heal($this->getAPI()),
            new ItemCommand($this->getAPI()),
            new ItemDB($this->getAPI()),
            new Jump($this->getAPI()),
            new KickAll($this->getAPI()),
            new Kit($this->getAPI()),
            new Lightning($this->getAPI()),
            new More($this->getAPI()),
            new Mute($this->getAPI()),
            new Near($this->getAPI()),
            new Nick($this->getAPI()),
            new Nuke($this->getAPI()),
            new Ping($this->getAPI()),
            new Feed($this->getAPI()),
            new PTime($this->getAPI()),
            new PvP($this->getAPI()),
            new RealName($this->getAPI()),
            new Repair($this->getAPI()),
            new Seen($this->getAPI()),
            new SetSpawn($this->getAPI()),
            new Spawn($this->getAPI()),
            //new Speed($this->getAPI()), TODO
            new Sudo($this->getAPI()),
            new Suicide($this->getAPI()),
            new TempBan($this->getAPI()),
            new Top($this->getAPI()),
            //new TreeCommand($this->getAPI()), TODO
            new Unlimited($this->getAPI()),
            new Vanish($this->getAPI()),
            //new Whois($this->getAPI()), TODO
            new World($this->getAPI()),
		
            // Messages
            new Msg($this->getAPI()),
            new Reply($this->getAPI()),
		
            // Override
            new Gamemode($this->getAPI()),
            new Kill($this->getAPI())		
	];
	    
	$economycommands = [
            new Balance($this->getAPI()),
            new Eco($this->getAPI()),
            new Pay($this->getAPI()),
            new Sell($this->getAPI()),
            new SetWorth($this->getAPI()),
            new Worth($this->getAPI()),
            new BalanceTop($this->getAPI())
        ];
	    
	$homecommands = [
            new DelHome($this->getAPI()),
            new Home($this->getAPI()),
            new SetHome($this->getAPI())
	];
	    
	$powertoolcommands = [
            new PowerTool($this->getAPI())
	];
		
	$teleportcommands = [
            new TPA($this->getAPI()),
            new TPAccept($this->getAPI()),
            new TPAHere($this->getAPI()),
            new TPAll($this->getAPI()),
            new TPDeny($this->getAPI()),
            new TPHere($this->getAPI())
	];
	    
	$warpcommands = [
            new DelWarp($this->getAPI()),
            new Setwarp($this->getAPI()),
            new Warp($this->getAPI())
        ];
	    
	    
	if($this->getServer()->getPluginManager()->getPlugin("SimpleWarp") === null) {
            foreach($warpcommands as $warpcommand) {
	        if($this->getConfig()->get("warps") === true) {
		    $commands[] = $warpcommand;
	        }
	    }
        } else {
            $this->getLogger()->info(TextFormat::YELLOW . "SimpleWarp installed, disabling EssentialsPE warps...");
        }
	  
	foreach($teleportcommands as $teleportcommand) {
	    if($this->getConfig()->get("teleporting") === true) {
		 $commands[] = $teleportcommand;
	    }
	}
        
	foreach($powertoolcommands as $powertoolcommand) {
	    if($this->getConfig()->get("powertool") === true) {
		 $commands[] = $powertoolcommand;
	    }
	}
	    
	foreach($homecommands as $homecommand) {
	    if($this->getConfig()->get("homes") === true) {
		 $commands[] = $homecommand;
	    }
	}	    
	foreach($economycommands as $economycommand) {
	    if($this->getConfig()->get("economy") === true) {
		 $commands[] = $economycommand;
	    }
	}
	    
        $aliased = [];
        foreach($commands as $cmd){
            /** @var BaseCommand $cmd */
            $commands[$cmd->getName()] = $cmd;
            $aliased[$cmd->getName()] = $cmd->getName();
            foreach($cmd->getAliases() as $alias){
                $aliased[$alias] = $cmd->getName();
            }
        }
        $cfg = $this->getConfig()->get("commands", []);
        foreach($cfg as $del){
            if(isset($alias[$del])){
                unset($commands[$alias[$del]]);
            }else{
                $this->getLogger()->debug("\"$del\" command not found inside EssentialsPE, skipping...");
            }
        }
        $this->getServer()->getCommandMap()->registerAll("EssentialsPE", $commands);
    }

    public function checkConfig(){
        if(!is_dir($this->getDataFolder())){
            mkdir($this->getDataFolder());
        }
        if(!file_exists($this->getDataFolder() . "config.yml")){
            $this->saveDefaultConfig();
        }
        $this->saveResource("Economy.yml");
        $this->saveResource("Kits.yml");
        $this->saveResource("Warps.yml");
        $cfg = $this->getConfig();

        if(!$cfg->exists("version") || $cfg->get("version") !== "0.0.3"){
            $this->getLogger()->debug(TextFormat::RED . "An invalid config file was found, generating a new one...");
            rename($this->getDataFolder() . "config.yml", $this->getDataFolder() . "config.yml.old");
            $this->saveDefaultConfig();
            $cfg = $this->getConfig();
        }

        $booleans = ["enable-custom-colors"];
        foreach($booleans as $key){
            $value = null;
            if(!$cfg->exists($key) || !is_bool($cfg->get($key))){
                switch($key){
                    // Properties to auto set true
                    case "safe-afk":
                        $value = true;
                        break;
                    // Properties to auto set false
                    case "enable-custom-colors":
                        $value = false;
                        break;
                }
            }
            if($value !== null){
                $cfg->set($key, $value);
            }
        }

        $integers = ["oversized-stacks", "near-radius-limit", "near-default-radius"];
        foreach($integers as $key){
            $value = null;
            if(!is_numeric($cfg->get($key))){
                switch($key){
                    case "auto-afk-kick":
                        $value = 300;
                        break;
                    case "oversized-stacks":
                        $value = 64;
                        break;
                    case "near-radius-limit":
                        $value = 200;
                        break;
                    case "near-default-radius":
                        $value = 100;
                        break;
                }
            }
            if($value !== null){
                $cfg->set($key, $value);
            }
        }

        $afk = ["safe", "auto-set", "auto-broadcast", "auto-kick", "broadcast"];
        foreach($afk as $key){
            $value = null;
            $k = $this->getConfig()->getNested("afk." . $key);
            switch($key){
                case "safe":
                case "auto-broadcast":
                case "broadcast":
                    if(!is_bool($k)){
                        $value = true;
                    }
                    break;
                case "auto-set":
                case "auto-kick":
                    if(!is_int($k)){
                        $value = 300;
                    }
                    break;
            }
            if($value !== null){
                $this->getConfig()->setNested("afk." . $key, $value);
            }
        }

        $updater = ["enabled", "time-interval", "warn-console", "warn-players", "channel"];
        foreach($updater as $key){
            $value = null;
            $k = $this->getConfig()->getNested("updater." . $key);
            switch($key){
                case "time-interval":
                    if(!is_int($k)){
                        $value = 1800;
                    }
                    break;
                case "enabled":
                case "warn-console":
                case "warn-players":
                    if(!is_bool($k)){
                        $value = true;
                    }
                    break;
                case "channel":
                    if(!is_string($k) || ($k !== "stable" && $k !== "beta" && $k !== "development")){
                        $value = "stable";
                    }
            }
            if($value !== null){
                $this->getConfig()->setNested("updater." . $key, $value);
            }
        }
    }

    /**
     * @return BaseAPI
     */
    public function getAPI(): BaseAPI{
        return $this->api;
    }
}
# EssentialsPE configuration
# This configuration file lets you modify how EssentialsPE work with some features

# DO NOT EDIT THIS PROPERTY! For internal use ONLY
version: "0.0.3"

# SET THIS TO "TRUE" TO ENABLE THIS PLUGIN
enable: true

# Disable various command features of EssentialsPE, set to false to disable
homes: true
warps: true
powertool: true
teleporting: true
economy: false

# Edit different parts of the AFK feature!
afk:
  # Players that are AFK can, or not, be damaged
  safe: true
  # Time until a player is known as AFK
  # You can disable this feature by assigning a value lower to 0
  auto-set: 300
  # This option et you enable or disable the "Auto-AFK" broadcast status,
  # So when someone is automatically set into AFK for idling, it will be broadcasted... Or not
  auto-broadcast: true
  # Time until a player is kicked for being AFK
  # You can disable this feature by assigning a value lower to 0
  auto-kick: 300
  # Allow the broadcasting of the AFK status of a player
  broadcast: true

# Let you configure the size of a stack that players (with permission) can get (via /more or /item)
oversized-stacks: 64

# Let you set a limit for the /near command to search for players (in blocks)
near-radius-limit: 200
# Let you set a default value to search for players (it can't be higher than the default limit)
near-default-radius: 200

# This option let you enable color codes in the server, but keep in mind that the client may not support them
enable-custom-colors: false

# These options will let you configure how the auto-updater will work
updater:
  # Enable the AUTOMATIC updater
  enabled: true
  # Allow to set a time interval for the auto-updater to work (In seconds) [Default is 30 minutes {1800 seconds}]
  time-interval: 1800
  # Do you want to warn the console?
  warn-console: true
  # Do you want to warn players with the permission 'essentials.update'?
  warn-players: true
  # Do you want to use 'stable', 'beta' or 'development' releases?
  channel: stable
# Sets the balance of a new player when join.
default-balance: 0

# The symbol to represent currency
currency-symbol: '$'

# Max money, to prevent your server crash because of high values.
max-money: 10000000000000

# Allow players to have negative values of money
min-money: -1000

# The default price to sell items using the /sell command.
# Please only use Item ID's here
worth:
  14: 25
  15: 20
  16: 15
  56: 50
  262: 10
  364: 15

# The balance of all the players
player-balances: []---
iksaku:
- 32
- 329
- 331
- 340
- 341
...
<?php
namespace EssentialsPE\Events;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\Loader;
use pocketmine\event\plugin\PluginEvent;

class CreateAPIEvent extends PluginEvent{
    public static $handlerList = null;

    /** @var string */
    private $class;

    /**
     * @param Loader $plugin
     * @param BaseAPI::class $api
     */
    public function __construct(Loader $plugin, $api){
        parent::__construct($plugin);
        if(!is_a($api, BaseAPI::class, true)){
            throw new \RuntimeException("Class $api must extend " . BaseAPI::class);
        }
        $this->class = BaseAPI::class;
    }

    /**
     * @return string
     */
    public function getClass(): string{
        return $this->class;
    }

    /**
     * @param BaseAPI::class $api
     */
    public function setClass($api){
        if(!is_a($api, BaseAPI::class, true)){
            throw new \RuntimeException("Class $api must extend " . BaseAPI::class);
        }
        $this->class = $api;
    }
}<?php
namespace EssentialsPE\BaseFiles;

use EssentialsPE\Events\PlayerAFKModeChangeEvent;
use EssentialsPE\Events\PlayerFlyModeChangeEvent;
use EssentialsPE\Events\PlayerGodModeChangeEvent;
use EssentialsPE\Events\PlayerMuteEvent;
use EssentialsPE\Events\PlayerNickChangeEvent;
use EssentialsPE\Events\PlayerPvPModeChangeEvent;
use EssentialsPE\Events\PlayerUnlimitedModeChangeEvent;
use EssentialsPE\Events\PlayerVanishEvent;
use EssentialsPE\Events\SessionCreateEvent;
use EssentialsPE\Loader;
use EssentialsPE\Tasks\AFK\AFKKickTask;
use EssentialsPE\Tasks\AFK\AFKSetterTask;
use EssentialsPE\Tasks\GeoLocation;
use EssentialsPE\Tasks\TPRequestTask;
use EssentialsPE\Tasks\Updater\AutoFetchCallerTask;
use EssentialsPE\Tasks\Updater\UpdateFetchTask;
use EssentialsPE\Tasks\Updater\UpdateInstallTask;
use pocketmine\block\Block;
use pocketmine\command\CommandSender;
use pocketmine\entity\Effect;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\inventory\BaseInventory;
use pocketmine\item\Armor;
use pocketmine\item\Item;
use pocketmine\item\ItemBlock;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\level\Location;
use pocketmine\level\Position;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\ByteTag;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\nbt\tag\DoubleTag;
use pocketmine\nbt\tag\FloatTag;
use pocketmine\nbt\tag\ListTag;
use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\network\protocol\MobEffectPacket;
use pocketmine\network\protocol\SetTimePacket;
use pocketmine\OfflinePlayer;
use pocketmine\permission\Permission;
use pocketmine\Player;
use pocketmine\Server;
use pocketmine\utils\Config;
use pocketmine\utils\Random;
use pocketmine\utils\TextFormat;

class BaseAPI{
    /** @var Loader */
    private $ess;
    /** @var BaseAPI */
    private static $instance;

    /** @var Config */
    private $economy;
    /** @var array */
    private $kits = [];
    /** @var array */
    private $warps = [];

    /**
     * @param Loader $ess
     */
    public function __construct(Loader $ess){
        $this->ess = $ess;
        self::$instance = $this;
        $this->saveConfigs();
        $this->getServerGeoLocation();
    }

    public function __destruct(){
        $this->encodeWarps(true);
    }

    /**
     * @return Loader
     */
    public final function getEssentialsPEPlugin(): Loader{
        return $this->ess;
    }

    /**
     * @return Server
     */
    public function getServer(): Server{
        return $this->getEssentialsPEPlugin()->getServer();
    }

    /**
     * @return BaseAPI
     */
    public static function getInstance(): BaseAPI{
        return self::$instance;
    }

    private final function saveConfigs(){
        $this->economy = new Config($this->getEssentialsPEPlugin()->getDataFolder() . "Economy.yml", Config::YAML);
        $keys = ["default-balance", "max-money", "min-money"];
        foreach($keys as $k){
            if(!is_int($k)){
                $value = 0;
                switch($k){
                    case "default-balance":
                        $value = 0;
                    break;
                
                    case "max-money":
                        $value = 10000000000000;
                    break;
                
                    case "min-money":
                        $value = 0;
                    break;
                }
                $this->economy->set($k, $value);
            }
        }

        $this->loadKits();
        $this->loadWarps();
        $this->updateHomesAndNicks();
    }

    private final function updateHomesAndNicks(){
        if(file_exists($f = $this->getEssentialsPEPlugin()->getDataFolder() . "Homes.yml")){
            $cfg = new Config($f, Config::YAML);
            foreach($cfg->getAll() as $player => $home){
                if(is_array($home)){
                    continue;
                }
                $pCfg = $this->getSessionFile($player);
                foreach($home as $name => $values){
                    if(!$this->validateName($name, false) || !is_array($values)){
                        continue;
                    }
                    $pCfg->setNested("homes." . $name, $values);
                }
                $pCfg->save();
            }
            unlink($f);
        }
        if(file_exists($f = $this->getEssentialsPEPlugin()->getDataFolder() . "Nicks.yml")){
            $cfg = new Config($f, Config::YAML);
            foreach($cfg->getAll() as $player => $nick){
                $pCfg = $this->getSessionFile($player);
                $pCfg->set("nick", $nick);
                $pCfg->save();
            }
            unlink($f);
        }
    }

    private final function loadKits(){
        $cfg = new Config($this->getEssentialsPEPlugin()->getDataFolder() . "Kits.yml", Config::YAML);
        $children = [];
        foreach($cfg->getAll() as $n => $i){
            $this->kits[$n] = new BaseKit($n, $i);
            $children[] = new Permission("essentials.kits." . $n);
        }
        $this->getServer()->getPluginManager()->addPermission(new Permission("essentials.kits", null, null, $children));
    }

    private final function loadWarps(){
        $cfg = new Config($this->getEssentialsPEPlugin()->getDataFolder() . "Warps.yml", Config::YAML);
        $children = [];
        foreach($cfg->getAll() as $n => $v){
            if($this->getServer()->isLevelGenerated($v[3])){
                if(!$this->getServer()->isLevelLoaded($v[3])){
                    $this->getServer()->loadLevel($v[3]);
                }
                $this->warps[$n] = new BaseLocation($n, $v[0], $v[1], $v[2], $this->getServer()->getLevelByName($v[3]), $v[4], $v[5]);
                $children[] = new Permission("essentials.warps." . $n);
            }
        }
        $this->getServer()->getPluginManager()->addPermission(new Permission("essentials.warps", null, null, $children));
    }

    /**
     * @param bool $save
     */
    private final function encodeWarps(bool $save = false){
        $warps = [];
        foreach($this->warps as $name => $object){
            if($object instanceof BaseLocation){
                $warps[$name] = [$object->getX(), $object->getY(), $object->getZ(), $object->getLevel()->getName(), $object->getYaw(), $object->getPitch()];
            }
        }
        if($save && count($warps) > 0){
            $cfg = new Config($this->getEssentialsPEPlugin()->getDataFolder() . "Warps.yml", Config::YAML);
            $cfg->setAll($warps);
            $cfg->save();
        }
        $this->warps = $warps;
    }

    public function reloadFiles(){
        $this->getEssentialsPEPlugin()->getConfig()->reload();
        $this->economy->reload();
        $this->loadKits();
        $this->loadWarps();
        $this->updateHomesAndNicks();
    }

    /*
     *  .----------------.  .----------------.  .----------------.
     * | .--------------. || .--------------. || .--------------. |
     * | |      __      | || |   ______     | || |     _____    | |
     * | |     /  \     | || |  |_   __ \   | || |    |_   _|   | |
     * | |    / /\ \    | || |    | |__) |  | || |      | |     | |
     * | |   / ____ \   | || |    |  ___/   | || |      | |     | |
     * | | _/ /    \ \_ | || |   _| |_      | || |     _| |_    | |
     * | ||____|  |____|| || |  |_____|     | || |    |_____|   | |
     * | |              | || |              | || |              | |
     * | '--------------' || '--------------' || '--------------' |
     *  '----------------'  '----------------'  '----------------'
     *
     */

    const NON_SOLID_BLOCKS = [Block::SAPLING, Block::WATER, Block::STILL_WATER, Block::LAVA, Block::STILL_LAVA, Block::COBWEB, Block::TALL_GRASS, Block::BUSH, Block::DANDELION,
        Block::POPPY, Block::BROWN_MUSHROOM, Block::RED_MUSHROOM, Block::TORCH, Block::FIRE, Block::WHEAT_BLOCK, Block::SIGN_POST, Block::WALL_SIGN, Block::SUGARCANE_BLOCK,
        Block::PUMPKIN_STEM, Block::MELON_STEM, Block::VINE, Block::CARROT_BLOCK, Block::POTATO_BLOCK, Block::DOUBLE_PLANT];

    /**
     *            ______ _  __
     *      /\   |  ____| |/ /
     *     /  \  | |__  | ' /
     *    / /\ \ |  __| |  <
     *   / ____ \| |    | . \
     *  /_/    \_|_|    |_|\_\
     */

    /**
     * Tell if the player is AFK or not
     *
     * @param Player $player
     * @return bool
     */
    public function isAFK(Player $player): bool{
        return $this->getSession($player)->isAFK();
    }

    /**
     * Change the AFK mode of a player
     *
     * @param Player $player
     * @param bool $state
     * @param bool $broadcast
     * @return bool
     */
    public function setAFKMode(Player $player, bool $state, bool $broadcast = true): bool{
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerAFKModeChangeEvent($this, $player, $state, $broadcast));
        if($ev->isCancelled()){
            return false;
        }
        $state = $ev->getAFKMode();
        $this->getSession($player)->setAFK($state);
        $time = $this->getEssentialsPEPlugin()->getConfig()->getNested("afk.auto-kick");
        if(!$state && ($id = $this->getSession($player)->getAFKKickTaskID()) !== false){
            $this->getServer()->getScheduler()->cancelTask($id);
            $this->getSession($player)->removeAFKKickTaskID();
        }elseif($state && (is_int($time) && $time  > 0) && !$player->hasPermission("essentials.afk.kickexempt")){
            $task = $this->getServer()->getScheduler()->scheduleDelayedTask(new AFKKickTask($this, $player), ($time * 20));
            $this->getSession($player)->setAFKKickTaskID($task->getTaskId());
        }
        $player->sendMessage(TextFormat::YELLOW . "You're " . ($this->isAFK($player) ? "now" : "no longer") . " AFK");
        if($ev->getBroadcast()){
            $this->broadcastAFKStatus($player);
        }
        return true;
    }

    /**
     * Automatically switch the AFK mode on/off
     *
     * @param Player $player
     * @param bool $broadcast
     */
    public function switchAFKMode(Player $player, bool $broadcast = true){
        $this->setAFKMode($player, !$this->isAFK($player), $broadcast);
    }

    /**
     * For internal use ONLY
     *
     * This function schedules the global Auto-AFK setter
     */
    public function scheduleAutoAFKSetter(){
        if(is_int($v = $this->getEssentialsPEPlugin()->getConfig()->getNested("afk.auto-set")) && $v > 0){
            $this->getServer()->getScheduler()->scheduleDelayedTask(new AFKSetterTask($this), (600)); // Check every 30 seconds...
        }
    }

    /**
     * Get the last time that a player moved
     *
     * @param Player $player
     * @return int|null
     */
    public function getLastPlayerMovement(Player $player){
        return $this->getSession($player)->getLastMovement();
    }

    /**
     * Change the last time that a player moved
     *
     * @param Player $player
     * @param int $time
     */
    public function setLastPlayerMovement(Player $player, $time){
        if(!$player->hasPermission("essentials.afk.preventauto")){
            $this->getSession($player)->setLastMovement($time);
        }
    }

    /**
     * Broadcast the AFK status of a player
     *
     * @param Player $player
     */
    public function broadcastAFKStatus(Player $player){
        if(!$this->getEssentialsPEPlugin()->getConfig()->getNested("afk.broadcast")){
            return;
        }
        $message = TextFormat::YELLOW . $player->getDisplayName() . " is " . ($this->isAFK($player) ? "now" : "no longer") . " AFK";
        $this->getServer()->getLogger()->info($message);
        foreach($this->getServer()->getOnlinePlayers() as $p){
            if($p !== $player){
                $p->sendMessage($message);
            }
        }
    }

    /**  ____             _
     *  |  _ \           | |
     *  | |_) | __ _  ___| | __
     *  |  _ < / _` |/ __| |/ /
     *  | |_) | (_| | (__|   <
     *  |____/ \__,_|\___|_|\_\
     */

    /**
     * Return the last known spot of a player before teleporting
     *
     * @param Player $player
     * @return bool|Location
     */
    public function getLastPlayerPosition(Player $player){
        return $this->getSession($player)->getLastPosition();
    }

    /**
     * Updates the last position of a player.
     *
     * @param Player $player
     * @param Location $pos
     */
    public function setPlayerLastPosition(Player $player, Location $pos){
        $this->getSession($player)->setLastPosition($pos);
    }

    /**
     * @param Player $player
     */
    public function removePlayerLastPosition(Player $player){
        $this->getSession($player)->removeLastPosition();
    }

    /**  ______
     *  |  ____|
     *  | |__   ___ ___  _ __   ___  _ __ ___  _   _
     *  |  __| / __/ _ \| '_ \ / _ \| '_ ` _ \| | | |
     *  | |___| (_| (_) | | | | (_) | | | | | | |_| |
     *  |______\___\___/|_| |_|\___/|_| |_| |_|\__, |
     *                                          __/ |
     *                                         |___/
     */

    /**
     * Get the default balance for new players
     *
     * @return int
     */
    public function getDefaultBalance(): int{
        return $this->getEssentialsPEPlugin()->getConfig()->get("default-balance");
    }

    /**
     * Get the max balance that a player can own
     *
     * @return bool|mixed
     */
    public function getMaxBalance(){
        return $this->economy->get("max-money");
    }

    /**
     * Gets the minium balance that a player can own
     *
     * @return bool|mixed
     */
    public function getMinBalance(){
        return $this->economy->get("min-money");
    }

    /**
     * Returns the currency symbol
     *
     * @return string
     */
    public function getCurrencySymbol(): string{
        return $this->economy->get("currency-symbol");
    }
    
    /**
     * Return the top 5 players with most money
     * 
     * @return array
     */
    public function sendBalanceTop($sender) {
        $moneylist = $this->economy->get("player-balances");
        arsort($moneylist);
        $i = 0;
        foreach($moneylist as $player => $money) {
            if($i <= 4) {
                $sender->sendMessage($player . " - " . TextFormat::GREEN . $money);
            }
            $i++;
        }
        return true;
    }
    
    /**
     * Return the current balance of a player.
     *
     * @param Player $player
     * @return int
     */
    public function getPlayerBalance(Player $player): int{
        $balance = $this->economy->getNested("player-balances." . $player->getName());
        if(!$balance){
            $this->setPlayerBalance($player, $b = $this->getDefaultBalance());
            return $b;
        }
        return $balance;
    }

    /**
     * Sets the balance of a player
     *
     * @param Player $player
     * @param int $balance
     */
    public function setPlayerBalance(Player $player, int $balance){
        if($balance > $this->getMaxBalance()){
            $balance = $this->getMaxBalance();
        }elseif($balance < $this->getMinBalance()){
            $balance = $this->getMinBalance();
        }elseif($balance < 0 && !$player->hasPermission("essentials.eco.load")){
            $balance = 0;
        }
        $this->economy->setNested("player-balances." . $player->getName(), $balance);
        $this->economy->save();
    }

    /**
     * Sums a quantity to player's balance
     * NOTE: You can also specify negative quantities!
     *
     * @param Player $player
     * @param int $quantity
     */
    public function addToPlayerBalance(Player $player, int $quantity){
        $balance = $this->getPlayerBalance($player) + $quantity;
        if($balance > $this->getMaxBalance()){
            $balance = $this->getMaxBalance();
        }elseif($balance < $this->getMinBalance()){
            $balance = $this->getMinBalance();
        }elseif($balance < 0 && !$player->hasPermission("essentials.eco.loan")){
            $balance = 0;
        }
        $this->setPlayerBalance($player, $balance);
    }

    /**
     * Get the worth of an item
     *
     * @param int $itemId
     * @return int
     */
    public function getItemWorth(int $itemId): int{
        return $this->economy->getNested("worth." . $itemId, false);
    }

    /**
     * Sets the worth of an item
     *
     * @param int $itemId
     * @param int $worth
     */
    public function setItemWorth(int $itemId, int $worth){
        $this->economy->setNested("worth." . $itemId, $worth);
        $this->economy->save();
    }

    /**
     * @param Player $player
     * @param Item $item
     * @param int|null $amount
     * @return array|bool|int
     */
    public function sellPlayerItem(Player $player, Item $item, int $amount = null){
        if(!$this->getItemWorth($item->getId())){
            return false;
        }
        /** @var Item[] $contents */
        $contents = [];
        $quantity = 0;
        foreach($player->getInventory()->getContents() as $s => $i){
            if($i->getId() === $item->getId() && $i->getDamage() === $item->getDamage()){
                $contents[$s] = clone $i;
                $quantity += $i->getCount();
            }
        }
        $worth = $this->getItemWorth($item->getId());
        if($amount === null){
            $worth = $worth * $quantity;
            $player->getInventory()->remove($item);
            $this->addToPlayerBalance($player, $worth);
            return $worth;
        }
        $amount = (int) $amount;
        if($amount < 0){
            $amount = $quantity - $amount;
        }elseif($amount > $quantity){
            return -1;
        }

        $count = $amount;
        foreach($contents as $s => $i){
            if(($count - $i->getCount()) >= 0){
                $count = $count - $i->getCount();
                $i->setCount(0);
            }else{
                $c = $i->getCount() - $count;
                $i->setCount($c);
                $count = 0;
            }
            if($count <= 0){
                break;
            }
        }
        return [$amount, $worth];
    }
    
    /**
     * @param Player $player
     * @param int $amount
     * @return bool
     */
    public function hasPlayerBalance(Player $player, int $amount): bool {
        if($this->getPlayerBalance($player) >= $amount) {
            return true;
        }
        return false;
    }

    /**  ______       _   _ _   _
     *  |  ____|     | | (_| | (_)
     *  | |__   _ __ | |_ _| |_ _  ___ ___
     *  |  __| | '_ \| __| | __| |/ _ / __|
     *  | |____| | | | |_| | |_| |  __\__ \
     *  |______|_| |_|\__|_|\__|_|\___|___/
     */

    /**
     * @param Player $player
     * @return bool
     */
    public function antioch(Player $player): bool{
        $block = $player->getTargetBlock(100, [0, 8, 9, 10, 11]);
        if($block === null){
            return false;
        }
        $this->createTNT($block->add(0, 1), $player->getLevel());
        return true;
    }

    /**
     * Spawn a carpet of bomb!
     *
     * @param Player $player
     */
    public function nuke(Player $player){
        for($x = -10; $x <= 10; $x += 5){
            for($z = -10; $z <= 10; $z += 5){
                $this->createTNT($player->add($x, 0, $z), $player->getLevel());
            }
        }
    }

    /**
     * @param string $type
     * @param Vector3 $pos
     * @param Level|null $level
     * @param CompoundTag|null $nbt
     * @return bool|Entity
     */
    public function createEntity(string $type , Vector3 $pos, Level $level = null, CompoundTag $nbt = null){
        if($level === null){
            if($pos instanceof Position){
                $level = $pos->getLevel();
            }else{
                return false;
            }
        }
        if($nbt === null){
            $nbt = new CompoundTag("EssPE", [
                "Pos" => new ListTag("Pos", [
                    new DoubleTag("x", $pos->getX()),
                    new DoubleTag("y", $pos->getY()).
                    new DoubleTag("z", $pos->getZ())
                ])
            ]);
        }
        $entity = Entity::createEntity($type, $level->getChunk($pos->getX() >> 4, $pos->getZ() >> 4), $nbt) ?? false;
        return $entity;
    }

    /**
     * @param Vector3|Position $pos
     * @param null|Level $level
     * @param bool $spawn
     * @return null|Entity
     */
    public function createTNT(Vector3 $pos, Level $level = null, $spawn = true){
        $mot = (new Random())->nextSignedFloat() * M_PI * 2;
        $entity = $this->createEntity("PrimedTNT", $pos, $level, new CompoundTag("EssPE", [
            "Pos" => new ListTag("Pos", [
                new DoubleTag("", $pos->getFloorX() + 0.5),
                new DoubleTag("", $pos->getFloorY()),
                new DoubleTag("", $pos->getFloorZ() + 0.5)
            ]),
            "Motion" => new ListTag("Motion", [
                new DoubleTag("", -sin($mot) * 0.02),
                new DoubleTag("", 0.2),
                new DoubleTag("", -cos($mot) * 0.02)
            ]),
            "Rotation" => new ListTag("Rotation", [
                new FloatTag("", 0),
                new FloatTag("", 0)
            ]),
            "Fuse" => new ByteTag("Fuse", 80),
        ]));
        if($spawn){
            $entity->spawnToAll();
        }
        return $entity;
    }

    /**
     * @param Position|Player $pos
     * @param int $damage
     */
    public function strikeLightning(Position $pos, int $damage = 0){
        $pk = $this->lightning($pos);
        foreach($pos->getLevel()->getPlayers() as $p){
            $p->dataPacket($pk);
        }
        if(!$pos instanceof Entity and !($pos = $this->createTNT($pos, null, false))){
            return;
        }
        foreach($pos->getLevel()->getNearbyEntities(new AxisAlignedBB($pos->getFloorX() - ($radius = 5), $pos->getFloorY() - $radius, $pos->getFloorZ() - $radius, $pos->getFloorX() + $radius, $pos->getFloorY() + $radius, $pos->getFloorZ() + $radius), $pos) as $e){
            $e->attack(0, new EntityDamageEvent($pos, EntityDamageEvent::CAUSE_MAGIC, $damage));
        }
    }

    /** @var null|AddEntityPacket */
    private $lightningPacket = null;

    /**
     * @param Vector3 $pos
     * @return AddEntityPacket
     */
    protected function lightning(Vector3 $pos): AddEntityPacket{
        if($this->lightningPacket === null){
            $pk = new AddEntityPacket();
            $pk->type = 93;
            $pk->eid = Entity::$entityCount++;
            $pk->metadata = [];
            $pk->speedX = 0;
            $pk->speedY = 0;
            $pk->speedZ = 0;
            $this->lightningPacket = $pk;
        }
        $this->lightningPacket->x = $pos->getX();
        $this->lightningPacket->y = $pos->getY();
        $this->lightningPacket->z = $pos->getZ();
        return $this->lightningPacket;
    }

    /**  ______ _
     *  |  ____| |
     *  | |__  | |_   _
     *  |  __| | | | | |
     *  | |    | | |_| |
     *  |_|    |_|\__, |
     *             __/ |
     *            |___/
     */

    /**
     * Get the "Can fly" status of a player
     *
     * @param Player $player
     * @return bool
     */
    public function canFly(Player $player): bool{
        return $player->getAllowFlight();
    }

    /**
     * Set the "flying" allowed status to a player
     *
     * @param Player $player
     * @param bool $mode
     * @return bool
     */
    public function setFlying(Player $player, bool $mode): bool{
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerFlyModeChangeEvent($this, $player, $mode));
        if($ev->isCancelled()){
            return false;
        }
        $player->setAllowFlight($ev->willFly());
        return true;
    }

    /**
     * Automatically switch a player between "Can" and "Can't" fly
     *
     * @param Player $player
     */
    public function switchCanFly(Player $player){
        $this->setFlying($player, !$this->canFly($player));
    }

    /**   _____            _                     _   _
     *   / ____|          | |                   | | (_)
     *  | |  __  ___  ___ | |     ___   ___ __ _| |_ _  ___  _ __
     *  | | |_ |/ _ \/ _ \| |    / _ \ / __/ _` | __| |/ _ \| '_ \
     *  | |__| |  __| (_) | |___| (_) | (_| (_| | |_| | (_) | | | |
     *   \_____|\___|\___/|______\___/ \___\__,_|\__|_|\___/|_| |_|
     */

    /** @var string */
    private $serverGeoLocation = "Unknown";

    /**
     * @param Player $player
     * @return string|null
     */
    public function getGeoLocation(Player $player){
        return $this->getSession($player)->getGeoLocation();
    }

    /**
     * @return string
     */
    public function getServerGeoLocation(): string{
        if($this->serverGeoLocation === null){
            $this->getServer()->getScheduler()->scheduleAsyncTask(new GeoLocation(null));
        }
        return $this->serverGeoLocation;
    }

    /**
     * @param Player $player
     * @param string $location
     */
    public function updateGeoLocation(Player $player, string $location){
        $this->getSession($player)->setGeoLocation($location);
    }

    /**
     * @param string $location
     */
    public function setServerGeoLocation(string $location){
        if($this->serverGeoLocation === null){
            $this->serverGeoLocation = $location;
        }
    }

    /**   _____           _
     *   / ____|         | |
     *  | |  __  ___   __| |
     *  | | |_ |/ _ \ / _` |
     *  | |__| | (_) | (_| |
     *   \_____|\___/ \__,_|
     */

    /**
     * Tell if a player is in God Mode
     *
     * @param Player $player
     * @return bool
     */
    public function isGod(Player $player): bool{
        return $this->getSession($player)->isGod();
    }

    /**
     * Set the God Mode on or off
     *
     * @param Player $player
     * @param bool $state
     * @return bool
     */
    public function setGodMode(Player $player, bool $state): bool{
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerGodModeChangeEvent($this, $player, $state));
        if($ev->isCancelled()){
            return false;
        }
        $this->getSession($player)->setGod($ev->getGodMode());
        return true;
    }

    /**
     * Switch God Mode on/off automatically
     *
     * @param Player $player
     */
    public function switchGodMode(Player $player){
        $this->setGodMode($player, !$this->isGod($player));
    }

    /**  _    _
     *  | |  | |
     *  | |__| | ___  _ __ ___   ___ ___
     *  |  __  |/ _ \| '_ ` _ \ / _ / __|
     *  | |  | | (_) | | | | | |  __\__ \
     *  |_|  |_|\___/|_| |_| |_|\___|___/
     */

    /**
     * Tell is a player have a specific home by its name
     *
     * @param Player $player
     * @param string $home
     * @return bool
     */
    public function homeExists(Player $player, string $home): bool{
        return $this->sessionExists($player) && $this->getSession($player)->homeExists($home);
    }

    /**
     * Return the home information (Position and Rotation)
     *
     * @param Player $player
     * @param string $home
     * @return bool|BaseLocation
     */
    public function getHome(Player $player, string $home){
        return $this->getSession($player)->getHome($home);
    }

    /**
     * Create or update a home
     *
     * @param Player $player
     * @param string $home
     * @param Position $pos
     * @param float $yaw
     * @param float $pitch
     * @return bool
     */
    public function setHome(Player $player, string$home, Position $pos, float $yaw = 0.0, float $pitch = 0.0): bool{
        return $this->getSession($player)->setHome($home, ($pos instanceof Location ? $pos : Location::fromObject($pos, $pos->getLevel(), $yaw, $pitch)));
    }

    /**
     * Removes a home
     *
     * @param Player $player
     * @param string $home
     * @return bool
     */
    public function removeHome(Player $player, string $home): bool{
        return $this->getSession($player)->removeHome($home);
    }

    /**
     * Return a list of all the available homes of a certain player
     *
     * @param Player $player
     * @param bool $inArray
     * @return array|bool|string
     */
    public function homesList(Player $player, bool $inArray = false){
        return $this->getSession($player)->homesList($inArray);
    }

    /**  _____ _
     *  |_   _| |
     *    | | | |_ ___ _ __ ___  ___
     *    | | | __/ _ | '_ ` _ \/ __|
     *   _| |_| ||  __| | | | | \__ \
     *  |_____|\__\___|_| |_| |_|___/
     */

    /**
     * Easy get an item by name and metadata.
     * The way this function understand the information about the item is:
     * 'ItemNameOrID:Metadata' - Example (Granite block item):
     *      '1:1' - or - 'stone:1'
     *
     * @param string $item_name
     * @return Item|ItemBlock
     */
    public function getItem(string $item_name): Item{
        if(strpos($item_name, ":") !== false){
            $v = explode(":", $item_name);
            $item_name = $v[0];
            $damage = (int) $v[1];
        }else{
            $damage = 0;
        }

        if(!is_numeric($item_name)){
            $item = Item::fromString($item_name);
        }else{
            $item = Item::get($item_name);
        }
        $item->setDamage($damage);

        return $item;
    }

    /**
     * Let you know if the item is a Tool or Armor
     * (Items that can get "real damage")
     *
     * @param Item $item
     * @return bool
     */
    public function isRepairable(Item $item): bool{
        return $item instanceof Tool || $item instanceof Armor;
    }

    /**
     * Condense items into blocks in an inventory, default MCPE item calculations (recipes) are used.
     *
     * @param BaseInventory $inv
     * @param Item|null $target
     * @return bool
     */
    public function condenseItems(BaseInventory $inv, Item $target = null): bool{ // TODO: Fix inventory clear...
        $items = $target === null ? $inv->getContents() : $inv->all($target);
        if($target !== null && !$this->canBeCondensed($target)){
            return false;
        }
        $replace = Item::get(0);
        // First step: Merge target items...
        foreach($items as $slot => $item){
            if(!isset($this->condenseShapes[0][$item->getId()]) && !isset($this->condenseShapes[1][$item->getId()])){
                continue;
            }
            $sub = $inv->all($item);
            foreach($sub as $index => $i){
                /** @var Item $i */
                if($slot !== $index){
                    $item->setCount($item->getCount() + $i->getCount());
                    $items[$index] = $replace;
                    var_dump($index . " - " . $slot);
                }
            }
        }
        $inv->setContents($items);
        // Second step: Condense items...
        foreach($items as $slot => $item){
            $condense = $this->condenseRecipes($item);
            if($condense === null){
                continue;
            }
            $cSlot = $slot;
            if($item->getCount() > 0){
                $cSlot = $inv->firstEmpty();
                $inv->setItem($slot, $item);
            }
            $inv->setItem($cSlot, $condense);
        }
        return true;
    }

    /** @var array */
    private $condenseShapes = [
        [], // 2x2 Shapes TODO
        [Item::COAL => Item::COAL_BLOCK, Item::IRON_INGOT => Item::IRON_BLOCK, Item::GOLD_INGOT => Item::GOLD_BLOCK, Item::DIAMOND => Item::DIAMOND_BLOCK, Item::EMERALD => Item::EMERALD_BLOCK] // 3x3 Shapes
    ];

    /**
     * @param Item $item
     * @return Item|null
     */
    private function condenseRecipes(Item $item){
        if(isset($this->condenseShapes[0][$item->getId()])){ // 2x2 Shapes
            $shape = 4;
        }elseif(isset($this->condenseShapes[1][$item->getId()])){ // 3x3 Shapes
            $shape = 9;
        }else{
            return null;
        }
        $index = (int) sqrt($shape) - 2;
        $newId = $this->condenseShapes[$index][$item->getId()];
        $damage = 0;
        if(is_array($newId)){
            if(!isset($newId[1][$item->getDamage()])){
                return null;
            }
            $damage = $newId[1][$item->getDamage()];
            $newId = $newId[0];
        }
        $count = floor($item->getCount() / $shape);
        if($count < 1){
            return null;
        }
        $condensed = new Item($newId, $damage, $count);
        if($condensed->getId() === Item::AIR){
            return null;
        }
        $item->setCount($item->getCount() - ($count * $shape));
        return $condensed;
    }

    /**
     * @param Item $item
     * @return bool
     */
    public function canBeCondensed(Item $item): bool{
        return isset($this->condenseShapes[0][$item->getId()]) || isset($this->condenseShapes[1][$item->getId()]);
    }

    /**  _  ___ _
     *  | |/ (_| |
     *  | ' / _| |_ ___
     *  |  < | | __/ __|
     *  | . \| | |_\__ \
     *  |_|\_|_|\__|___/
     */

    /**
     * Check if a kit exists
     *
     * @param string $kit
     * @return bool
     */
    public function kitExists(string $kit): bool{
        return $this->validateName($kit, false) && isset($this->kits[$kit]);
    }

    /**
     * Return the contents of a kit, if existent
     *
     * @param string $kit
     * @return bool|BaseKit
     */
    public function getKit(string $kit){
        if(!$this->kitExists($kit)){
            return false;
        }
        return $this->kits[$kit];
    }

    /**
     * Get a list of all available kits
     *
     * @param bool $inArray
     * @return array|bool|string
     */
    public function kitList(bool $inArray = false){
        $list = array_keys($this->kits);
        if(count($list) < 1){
            return false;
        }
        if(!$inArray){
            return implode(", ", $list);
        }
        return $list;
    }

    /**  __  __
     *  |  \/  |
     *  | \  / | ___ ___ ___  __ _  __ _  ___ ___
     *  | |\/| |/ _ / __/ __|/ _` |/ _` |/ _ / __|
     *  | |  | |  __\__ \__ | (_| | (_| |  __\__ \
     *  |_|  |_|\___|___|___/\__,_|\__, |\___|___/
     *                              __/ |
     *                             |___/
     */

    /** @var MessagesAPI */
    private $messagesAPI = null;

    public function loadMessagesAPI(){
        //$this->messagesAPI = new MessagesAPI($this, $this->getFile() . "resources/Messages.yml"); TODO Directly implement in this class
    }

    /**
     * @return MessagesAPI
     */
    public function getMessagesAPI(): MessagesAPI{
        if($this->messagesAPI === null){
            $this->loadMessagesAPI();
        }
        return $this->messagesAPI;
    }

    /**
     * Return a colored message replacing every
     * color code (&a = §a)
     *
     * @param string $message
     * @param Player|null $player
     * @param bool $force
     * @return bool|string
     */
    public function colorMessage(string $message, Player $player = null, bool $force = false){
        $message = preg_replace_callback(
            "/(\\\&|\&)[0-9a-fk-or]/",
            function(array $matches){
                return str_replace("\\§", "&", str_replace("&", "§", $matches[0]));
            },
            $message
        );
        if(strpos($message, "§") !== false && ($player instanceof Player) && !$player->hasPermission("essentials.colorchat") && !$force){
            $player->sendMessage(TextFormat::RED . "You can't chat using colors!");
            return false;
        }
        return $message;
    }

    /**
     * Checks if a name is valid, it could be for a Nick, Home, Warp, etc...
     *
     * @param string $string
     * @param bool $allowColorCodes
     * @return bool
     */
    public function validateName(string $string, $allowColorCodes = false): bool{
        if(trim($string) === ""){
            return false;
        }
        $format = [];
        if($allowColorCodes){
            $format[] = "/(\&|\§)[0-9a-fk-or]/";
        }
        $format[] = "/[a-zA-Z0-9_]/"; // Due to color codes can be allowed, then check for them first, so after, make a normal lookup
        $s = preg_replace($format, "", $string);
        if(strlen($s) !== 0){
            return false;
        }
        return true;
    }

    /**   ____        _      _    _____            _
     *   / __ \      (_)    | |  |  __ \          | |
     *  | |  | |_   _ _  ___| | _| |__) |___ _ __ | |_   _
     *  | |  | | | | | |/ __| |/ |  _  // _ | '_ \| | | | |
     *  | |__| | |_| | | (__|   <| | \ |  __| |_) | | |_| |
     *   \___\_\\__,_|_|\___|_|\_|_|  \_\___| .__/|_|\__, |
     *                                      | |       __/ |
     *                                      |_|      |___/
     */

    /** @var array */
    private $quickReply = [
        "console" => false,
        "rcon" => false
    ];

    /**
     * Get the target for QuickReply, in string...
     *
     * @param CommandSender $sender
     * @return bool|string
     */
    public function getQuickReply(CommandSender $sender){
        if($sender instanceof Player){
            $q = $this->getSession($sender)->getQuickReply();
        }else{
            $q = $this->quickReply[strtolower($sender->getName())];
        }
        return $q;
    }

    /**
     * Assign a player to use with QuickReply
     *
     * @param CommandSender $messaged, The player that got the message
     * @param CommandSender $messenger, The player that sent the message
     */
    public function setQuickReply(CommandSender $messaged, CommandSender $messenger){
        if($messaged instanceof Player){
            $this->getSession($messaged)->setQuickReply($messenger);
        }else{
            $this->quickReply[strtolower($messaged->getName())] = $messenger->getName();
        }
    }

    /**
     * Removes QuickReply
     *
     * @param CommandSender $sender
     */
    public function removeQuickReply(CommandSender $sender){
        if($sender instanceof Player){
            $this->getSession($sender)->removeQuickReply();
        }else{
            $this->quickReply[strtolower($sender)] = false;
        }
    }

    /**  __  __       _
     *  |  \/  |     | |
     *  | \  / |_   _| |_ ___
     *  | |\/| | | | | __/ _ \
     *  | |  | | |_| | ||  __/
     *  |_|  |_|\__,_|\__\___|
     */

    /**
     * Tell if the is Muted or not
     *
     * @param Player $player
     * @return bool
     */
    public function isMuted(Player $player): bool{
        return $this->getSession($player)->isMuted();
    }

    /**
     * Tell the time until a player will be muted
     * false = If player is not muted
     * \DateTime = DateTime Object with corresponding time
     * null = Will keep muted forever
     *
     * @param Player $player
     * @return bool|\DateTime|null
     */
    public function getMutedUntil(Player $player){
        if(!$this->isMuted($player)){
            return false;
        }
        return $this->getSession($player)->getMutedUntil();
    }

    /**
     * Set the Mute mode on or off
     *
     * @param Player $player
     * @param bool $state
     * @param \DateTime|null $expires
     * @param bool $notify
     * @return bool
     */
    public function setMute(Player $player, bool $state, \DateTime $expires = null, bool $notify = true): bool{
        if($this->isMuted($player) !== $state){
            $this->getServer()->getPluginManager()->callEvent($ev = new PlayerMuteEvent($this, $player, $state, $expires));
            if($ev->isCancelled()){
                return false;
            }
            $this->getSession($player)->setMuted($ev->willMute(), $ev->getMutedUntil());
            if($notify && $player->hasPermission("essentials.mute.notify")){
                $player->sendMessage(TextFormat::YELLOW . "You have been " . ($this->isMuted($player) ? "muted " . ($ev->getMutedUntil() !== null ? "until: " . TextFormat::AQUA . $ev->getMutedUntil()->format("l, F j, Y") . TextFormat::RED . " at " . TextFormat::AQUA . $ev->getMutedUntil()->format("h:ia") : TextFormat::AQUA . "Forever" . TextFormat::YELLOW . "!") : "unmuted!"));
            }
        }
        return true;
    }

    /**
     * Switch the Mute mode on/off automatically
     *
     * @param Player $player
     * @param \DateTime|null $expires
     * @param bool $notify
     */
    public function switchMute(Player $player, \DateTime $expires = null, bool $notify = true){
        $this->setMute($player, !$this->isMuted($player), $expires, $notify);
    }

    /**  _   _ _      _
     *  | \ | (_)    | |
     *  |  \| |_  ___| | _____
     *  | . ` | |/ __| |/ / __|
     *  | |\  | | (__|   <\__ \
     *  |_| \_|_|\___|_|\_|___/
     */

    /**
     * Get players' saved Nicks
     *
     * @param Player $player
     * @return null|string
     */
    public function getNick(Player $player){
        return $this->getSession($player)->getNick();
    }

    /**
     * Change the player name for chat and even on his NameTag (aka Nick)
     *
     * @param Player $player
     * @param null|string $nick
     * @param bool $force
     * @return bool
     */
    public function setNick(Player $player, $nick, bool $force = false): bool{
        if(!$this->colorMessage($nick, $player, $force)){
            return false;
        }
        if(strtolower($nick) === strtolower($player->getName()) || $nick === "off" || trim($nick) === "" || $nick === null){
            return $this->removeNick($player);
        }
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerNickChangeEvent($this, $player, $this->colorMessage($nick)));
        if($ev->isCancelled()){
            return false;
        }
        $this->getSession($player)->setNick($ev->getNewNick());
        return true;
    }

    /**
     * Restore the original player name for chat and on his NameTag
     *
     * @param Player $player
     * @return bool
     */
    public function removeNick(Player $player): bool{
        $this->getServer()->getPluginManager()->callEvent($event = new PlayerNickChangeEvent($this, $player, $player->getName()));
        if($event->isCancelled()){
            return false;
        }
        $this->getSession($player)->setNick(null);
        return true;
    }

    /**  _____  _
     *  |  __ \| |
     *  | |__) | | __ _ _   _  ___ _ __
     *  |  ___/| |/ _` | | | |/ _ | '__|
     *  | |    | | (_| | |_| |  __| |
     *  |_|    |_|\__,_|\__, |\___|_|
     *                   __/ |
     *                  |___/
     */

    /**
     * Let you search for a player using his Display name(Nick) or Real name
     *
     * @param string $player
     * @return bool|Player
     */
    public function getPlayer($player){
        if(!$this->validateName($player, false)){
            return false;
        }
        $player = strtolower($player);
        $found = false;
        foreach($this->getServer()->getOnlinePlayers() as $p){
            if(strtolower(TextFormat::clean($p->getDisplayName(), true)) === $player || strtolower($p->getName()) === $player){
                $found = $p;
                break;
            }
        }
        // If cannot get the exact player name/nick, try with portions of it
        if(!$found){
            $found = ($f = $this->getServer()->getPlayer($player)) === null ? false : $f; // PocketMine function to get from portions of name
        }
        /*
         * Copy from PocketMine's function (use above xD) but modified to work with Nicknames :P
         *
         * ALL THE RIGHTS FROM THE FOLLOWING CODE BELONGS TO POCKETMINE-MP
         */
        if(!$found){
            $delta = \PHP_INT_MAX;
            foreach($this->getServer()->getOnlinePlayers() as $p){
                // Clean the Display Name due to colored nicks :S
                if(\stripos(($n = TextFormat::clean($p->getDisplayName(), true)), $player) === 0){
                    $curDelta = \strlen($n) - \strlen($player);
                    if($curDelta < $delta){
                        $found = $p;
                        $delta = $curDelta;
                    }
                    if($curDelta === 0){
                        break;
                    }
                }
            }
        }
        return $found;
    }
    /**
     * Let you search for a player using his Display name(Nick) or Real name
     * Instead of returning false, this method will create an OfflinePlayer object.
     *
     * @param string $name
     * @return Player|OfflinePlayer
     */
    public function getOfflinePlayer(string $name){
        $player = $this->getPlayer($name);
        if($player === false){
            $player = new OfflinePlayer($this->getServer(), strtolower($name));
        }
        return $player;
    }

    /**
     * Let you see who is near a specific player
     *
     * @param Player $player
     * @param int $radius
     * @return bool|Player[]
     */
    public function getNearPlayers(Player $player, int $radius = null){
        if($radius === null || !is_numeric($radius)){
            $radius = $this->getEssentialsPEPlugin()->getConfig()->get("near-default-radius");
        }
        if(!is_numeric($radius)){
            return false;
        }
        /** @var Player[] $players */
        $players = [];
        foreach($player->getLevel()->getNearbyEntities(new AxisAlignedBB($player->getFloorX() - $radius, $player->getFloorY() - $radius, $player->getFloorZ() - $radius, $player->getFloorX() + $radius, $player->getFloorY() + $radius, $player->getFloorZ() + $radius), $player) as $e){
            if($e instanceof Player){
                $players[] = $e;
            }
        }
        return $players;
    }

    /**
     * @param Player $player
     * @return array
     */
    public function getPlayerInformation(Player $player): array{
        return [
            "name" => $player->getName(),
            "nick" => $player->getDisplayName(),
            //"money" => $this->getPlayerBalance($player), TODO
            "afk" => $this->isAFK($player),
            "location" => $this->getGeoLocation($player)
        ];
    }

    /**  _____                    _______          _
     *  |  __ \                  |__   __|        | |
     *  | |__) _____      _____ _ __| | ___   ___ | |
     *  |  ___/ _ \ \ /\ / / _ | '__| |/ _ \ / _ \| |
     *  | |  | (_) \ V  V |  __| |  | | (_) | (_) | |
     *  |_|   \___/ \_/\_/ \___|_|  |_|\___/ \___/|_|
     */

    /**
     * Tell is PowerTool is enabled for a player, doesn't matter on what item
     *
     * @param Player $player
     * @return bool
     */
    public function isPowerToolEnabled(Player $player): bool{
        return $this->getSession($player)->isPowerToolEnabled();
    }

    /**
     * Run all the commands and send all the chat messages assigned to an item
     *
     * @param Player $player
     * @param Item $item
     * @return bool
     */
    public function executePowerTool(Player $player, Item $item): bool{
        $command = false;
        if($this->getPowerToolItemCommand($player, $item) !== false){
            $command = $this->getPowerToolItemCommand($player, $item);
        }elseif($this->getPowerToolItemCommands($player, $item) !== false){
            $command = $this->getPowerToolItemCommands($player, $item);
        }
        if($command !== false){
            if(!is_array($command)){
                $this->getServer()->dispatchCommand($player, $command);
            }else{
                foreach($command as $c){
                    $this->getServer()->dispatchCommand($player, $c);
                }
            }
        }
        if($chat = $this->getPowerToolItemChatMacro($player, $item) !== false){
            $this->getServer()->broadcast("<" . $player->getDisplayName() . "> " . TextFormat::RESET . $this->getPowerToolItemChatMacro($player, $item), Server::BROADCAST_CHANNEL_USERS);
        }
        if($command === false && $chat === false){
            return false;
        }
        return true;
    }

    /**
     * Sets a command for the item you have in hand
     * NOTE: If the hand is empty, it will be cancelled
     *
     * @param Player $player
     * @param Item $item
     * @param string $command
     * @return bool
     */
    public function setPowerToolItemCommand(Player $player, Item $item, string $command): bool{
        return $this->getSession($player)->setPowerToolItemCommand($item->getId(), $command);
    }

    /**
     * Return the command attached to the specified item if it's available
     * NOTE: Only return the command if there're no more commands, for that use "getPowerToolItemCommands" (note the "s" at the final :P)
     *
     * @param Player $player
     * @param Item $item
     * @return bool|string
     */
    public function getPowerToolItemCommand(Player $player, Item $item){
        return $this->getSession($player)->getPowerToolItemCommand($item->getId());
    }

    /**
     * Let you assign multiple commands to an item
     *
     * @param Player $player
     * @param Item $item
     * @param array $commands
     * @return bool
     */
    public function setPowerToolItemCommands(Player $player, Item $item, array $commands): bool{
        return $this->getSession($player)->setPowerToolItemCommands($item->getId(), $commands);
    }

    /**
     * Return a the list of commands assigned to an item
     * (if they're more than 1)
     *
     * @param Player $player
     * @param Item $item
     * @return bool|array
     */
    public function getPowerToolItemCommands(Player $player, Item $item){
        return $this->getSession($player)->getPowerToolItemCommands($item->getId());
    }

    /**
     * Let you remove 1 command of the item command list
     * [ONLY if there're more than 1)
     *
     * @param Player $player
     * @param Item $item
     * @param string $command
     */
    public function removePowerToolItemCommand(Player $player, Item $item, string $command){
        $this->getSession($player)->removePowerToolItemCommand($item->getId(), $command);
    }

    /**
     * Set a chat message to broadcast has the player
     *
     * @param Player $player
     * @param Item $item
     * @param string $chat_message
     * @return bool
     */
    public function setPowerToolItemChatMacro(Player $player, Item $item, string $chat_message): bool{
        return $this->getSession($player)->setPowerToolItemChatMacro($item->getId(), $chat_message);
    }

    /**
     * Get the message to broadcast has the player
     *
     * @param Player $player
     * @param Item $item
     * @return bool|string
     */
    public function getPowerToolItemChatMacro(Player $player, Item $item){
        return $this->getSession($player)->getPowerToolItemChatMacro($item->getId());
    }

    /**
     * Remove the command only for the item in hand
     *
     * @param Player $player
     * @param Item $item
     */
    public function disablePowerToolItem(Player $player, Item $item){
        $this->getSession($player)->disablePowerToolItem($item->getId());
    }

    /**
     * Remove the commands for all the items of a player
     *
     * @param Player $player
     */
    public function disablePowerTool(Player $player){
        $this->getSession($player)->disablePowerTool();
    }

    /**  _____        _____
     *  |  __ \      |  __ \
     *  | |__) __   _| |__) |
     *  |  ___/\ \ / |  ___/
     *  | |     \ V /| |
     *  |_|      \_/ |_|
     */

    /**
     * Tell if the PvP mode is enabled for the specified player, or not
     *
     * @param Player $player
     * @return bool
     */
    public function isPvPEnabled(Player $player): bool{
        return $this->getSession($player)->isPVPEnabled();
    }

    /**
     * Set the PvP mode on or off
     *
     * @param Player $player
     * @param bool $state
     * @return bool
     */
    public function setPvP(Player $player, bool $state): bool{
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerPvPModeChangeEvent($this, $player, $state));
        if($ev->isCancelled()){
            return false;
        }
        $this->getSession($player)->setPvP($ev->getPvPMode());
        return true;
    }

    /**
     * Switch the PvP mode on/off automatically
     *
     * @param Player $player
     */
    public function switchPvP(Player $player){
        $this->setPvP($player, !$this->isPvPEnabled($player));
    }

    /**   _____              _
     *   / ____|            (_)
     *  | (___   ___ ___ ___ _  ___  _ __  ___
     *   \___ \ / _ / __/ __| |/ _ \| '_ \/ __|
     *   ____) |  __\__ \__ | | (_) | | | \__ \
     *  |_____/ \___|___|___|_|\___/|_| |_|___/
     */

    /** @var array  */
    private $sessions = [];

    /**     * Tell if a session exists for a specific player
     *
     * @param Player $player
     * @return bool
     */
    public function sessionExists(Player $player): bool{
        return isset($this->sessions[spl_object_hash($player)]);
    }

    /**
     * Creates a new Sessions for the specified player
     *
     * @param Player|Player[] $player
     * @return array
     */
    public function createSession($player): array{
        if(!is_array($player)){
            $player = [$player];
        }
        $r = [];
        foreach($player as $i => $p){
            $spl = spl_object_hash($p);
            if(!isset($this->sessions[$spl])){
                $this->getEssentialsPEPlugin()->getLogger()->debug("Creating player session file...");
                $cfg = $this->getSessionFile($p->getName());
                $tValues = $cfg->getAll();
                $values = BaseSession::$defaults;
                foreach($tValues as $k => $v){
                    $values[$k] = $v;
                }
                $this->getEssentialsPEPlugin()->getLogger()->debug("Creating virtual session...");
                $this->getServer()->getPluginManager()->callEvent($ev = new SessionCreateEvent($this, $p, $values));
                $this->getEssentialsPEPlugin()->getLogger()->debug("Setting up new values...");
                $values = $ev->getValues();
                $m = BaseSession::$defaults["isMuted"];
                $mU = BaseSession::$defaults["mutedUntil"];
                if(isset($values["isMuted"])){
                    if(!isset($values["mutedUntil"])){
                        $values["mutedUntil"] = null;
                    }
                    $m = $values["isMuted"];
                    if(is_int($t = $values["mutedUntil"])){
                        $date = new \DateTime();
                        $mU = date_timestamp_set($date, $values["mutedUntil"]);
                    }else{
                        $mU = $values["mutedUntil"];
                    }
                    unset($values["isMuted"]);
                    unset($values["mutedUntil"]);
                }
                $n = $p->getName();
                if(isset($values["nick"])){
                    $n = $values["nick"];
                    $this->getEssentialsPEPlugin()->getLogger()->info($p->getName() . " is also known as " . $n);
                    unset($values["nick"]);
                }
                $v = BaseSession::$defaults["isVanished"];
                $vNP = BaseSession::$defaults["noPacket"];
                if(isset($values["isVanished"])){
                    if(!isset($values["noPacket"])){
                        $values["noPacket"] = false;
                    }
                    $v = $values["isVanished"];
                    $vNP = $values["noPacket"];
                    unset($values["isVanished"]);
                    unset($values["noPacket"]);
                }
                $this->getEssentialsPEPlugin()->getLogger()->debug("Setting up final values...");
                $this->sessions[$spl] = new BaseSession($this, $p, $cfg, $values);
                $this->setMute($p, $m, $mU);
                $this->setNick($p, $n, true);
            }
            $r[] = $this->sessions[$spl];
        }
        $this->getServer()->getScheduler()->scheduleAsyncTask(new GeoLocation($player));
        $this->getEssentialsPEPlugin()->getLogger()->debug("Finished session creation.");
        return $r;
    }

    /**
     * @param $player
     * @return bool|Config
     */
    private function getSessionFile(string $player){
        $this->getEssentialsPEPlugin()->getLogger()->info("Running");
        if(!is_dir($dir = $this->getEssentialsPEPlugin()->getDataFolder() . "Sessions" . DIRECTORY_SEPARATOR)){
            mkdir($dir);
        }
        if(!is_dir($dir = $dir . strtolower(substr($player, 0, 1)) . DIRECTORY_SEPARATOR)){
            mkdir($dir);
        }
        return new Config($dir . strtolower($player) . ".session", Config::JSON, BaseSession::$configDefaults);
    }

    /**
     * Remove player's session (if active and available)
     *
     * @param Player|Player[] $player
     */
    public function removeSession($player){
        if(!is_array($player)){
            $player = [$player];
        }
        foreach($player as $p){
            if($this->sessionExists($p)){
                $this->getSession($p)->onClose();
                unset($this->sessions[spl_object_hash($p)]);
            }
        }
    }

    /**
     * @param Player $player
     * @return BaseSession
     */
    private function getSession(Player $player): BaseSession{
        if(!$this->sessionExists($player)){
            $this->createSession($player);
        }
        return $this->sessions[spl_object_hash($player)];
    }

    /**  _______ _
     *  |__   __(_)
     *     | |   _ _ __ ___   ___
     *     | |  | | '_ ` _ \ / _ \
     *     | |  | | | | | | |  __/
     *     |_|  |_|_| |_| |_|\___|
     */

    /**
     * Change the time of a player
     *
     * @param Player $player
     * @param int $time
     * @param bool $static
     * @return bool
     */
    public function setPlayerTime(Player $player, int $time, bool $static = false): bool{
        $pk = new SetTimePacket();
        $pk->time = $time;
        $pk->started = !$static;
        $pk->encode();
        $pk->isEncoded = true;
        $player->dataPacket($pk);
        if(isset($pk->__encapsulatedPacket)){
            unset($pk->__encapsulatedPacket);
        }
        return true;
    }

    /**
     * Return an array with the following values:
     * 0 => Timestamp integer
     * 1 => The rest of the string (removing any "space" between time codes)
     *
     * @param string $string
     * @return array|bool
     */
    public function stringToTimestamp(string $string){
        /**
         * Rules:
         * Integers without suffix are considered as seconds
         * "s" is for seconds
         * "m" is for minutes
         * "h" is for hours
         * "d" is for days
         * "w" is for weeks
         * "mo" is for months
         * "y" is for years
         */
        if(trim($string) === ""){
            return false;
        }
        $t = new \DateTime();
        preg_match_all("/[0-9]+(y|mo|w|d|h|m|s)|[0-9]+/", $string, $found);
        if(count($found[0]) < 1){
            return false;
        }
        $found[2] = preg_replace("/[^0-9]/", "", $found[0]);
        foreach($found[2] as $k => $i){
            switch($c = $found[1][$k]){
                case "y":
                case "w":
                case "d":
                    $t->add(new \DateInterval("P" . $i. strtoupper($c)));
                    break;
                case "mo":
                    $t->add(new \DateInterval("P" . $i. strtoupper(substr($c, 0, strlen($c) -1))));
                    break;
                case "h":
                case "m":
                case "s":
                    $t->add(new \DateInterval("PT" . $i . strtoupper($c)));
                    break;
                default:
                    $t->add(new \DateInterval("PT" . $i . "S"));
                    break;
            }
            $string = str_replace($found[0][$k], "", $string);
        }
        return [$t, ltrim(str_replace($found[0], "", $string))];
    }

    /**  _______ _____  _____                           _
     *  |__   __|  __ \|  __ \                         | |
     *     | |  | |__) | |__) |___  __ _ _   _  ___ ___| |_ ___
     *     | |  |  ___/|  _  // _ \/ _` | | | |/ _ / __| __/ __|
     *     | |  | |    | | \ |  __| (_| | |_| |  __\__ | |_\__ \
     *     |_|  |_|    |_|  \_\___|\__, |\__,_|\___|___/\__|___/
     *                                | |
     *                                |_|
     */

    /**
     * Tell if a player has a pending request
     * Return false if not
     * Return array with all the names of the requesters and the actions to perform of each:
     *      "tpto" means that the requester wants to tp to the target position
     *      "tphere" means that the requester wants to tp the target to its position
     *
     * @param Player $player
     * @return bool|array
     */
    public function hasARequest(Player $player){
        return $this->getSession($player)->hasARequest();
    }

    /**
     * Tell if a player ($target) as a request from a specific player ($requester)
     * Return false if not
     * Return the type of request made:
     *      "tpto" means that the requester wants to tp to the target position
     *      "tphere" means that the requester wants to tp the target to its position
     *
     * @param Player $target
     * @param Player $requester
     * @return bool|string
     */
    public function hasARequestFrom(Player $target, Player $requester){
        return $this->getSession($target)->hasARequestFrom($requester->getName());
    }

    /**
     * Return the name of the latest teleport requester for a specific player
     *
     * @param Player $player
     * @return bool|string
     */
    public function getLatestRequest(Player $player){
        return $this->getSession($player)->getLatestRequestFrom();
    }

    /**
     * Tell if a player made a request to another player
     * Return false if not
     * Return array with the name of the target and the action to perform:
     *      "tpto" means that the requester wants to tp to the target position
     *      "tphere" means that the requester wants to tp the target to its position
     *
     * @param Player $player
     * @return array|bool
     */
    public function madeARequest(Player $player){
        return $this->getSession($player)->madeARequest();
    }

    /**
     * Schedule a Request to move $requester to $target's position
     *
     * @param Player $requester
     * @param Player $target
     */
    public function requestTPTo(Player $requester, Player $target){
        $this->getSession($requester)->requestTP($target->getName(), "tpto");

        $this->getSession($target)->receiveRequest($requester->getName(), "tpto");

        $this->scheduleTPRequestTask($requester);
    }

    /**
     * Schedule a Request to mode $target to $requester's position
     *
     * @param Player $requester
     * @param Player $target
     */
    public function requestTPHere(Player $requester, Player $target){
        $this->getSession($requester)->requestTP($target->getName(), "tphere");

        $this->getSession($target)->receiveRequest($requester->getName(), "tphere");

        $this->scheduleTPRequestTask($requester);
    }

    /**
     * Cancel the Request made by a player
     *
     * @param Player $requester
     * @param Player $target
     * @return bool
     */
    public function removeTPRequest(Player $requester, Player $target = null): bool{
        if(!$this->getSession($requester)->madeARequest() && $target === null){
            return false;
        }

        if($target !== null && $this->getSession($requester)->madeARequestTo($target->getName())){
            $this->getSession($requester)->cancelTPRequest();
            $this->getSession($target)->removeRequestFrom($requester->getName());
        }elseif($target === null){
            $target = $this->getPlayer($this->getSession($requester)->madeARequest()[0]);
            $this->getSession($requester)->cancelTPRequest();
            if($target !== false){
                $this->getSession($target)->removeRequestFrom($requester->getName());
            }
        }

        $this->cancelTPRequestTask($requester);
        return true;
    }

    /**
     * Schedule the Request auto-remover task (Internal use ONLY!)
     *
     * @param Player $player
     */
    private function scheduleTPRequestTask(Player $player){
        $task = $this->getServer()->getScheduler()->scheduleDelayedTask(new TPRequestTask($this, $player), 20 * 60 * 5);
        $this->getSession($player)->setRequestToTaskID($task->getTaskId());
    }

    /**
     * Cancel the Task (Internal use ONLY!)
     *
     * @param Player $player
     */
    private function cancelTPRequestTask(Player $player){
        $this->getServer()->getScheduler()->cancelTask($this->getSession($player)->getRequestToTaskID());
        $this->getSession($player)->removeRequestToTaskID();
    }


    /**  _    _       _ _           _ _           _   _____ _
     *  | |  | |     | (_)         (_| |         | | |_   _| |
     *  | |  | |_ __ | |_ _ __ ___  _| |_ ___  __| |   | | | |_ ___ _ __ ___  ___
     *  | |  | | '_ \| | | '_ ` _ \| | __/ _ \/ _` |   | | | __/ _ | '_ ` _ \/ __|
     *  | |__| | | | | | | | | | | | | ||  __| (_| |  _| |_| ||  __| | | | | \__ \
     *   \____/|_| |_|_|_|_| |_| |_|_|\__\___|\__,_| |_____|\__\___|_| |_| |_|___/
     */

    /**
     * Tells if the unlimited mode is enabled
     *
     * @param Player $player
     * @return bool
     */
    public function isUnlimitedEnabled(Player $player): bool{
        return $this->getSession($player)->isUnlimitedEnabled();
    }

    /**
     * Set the unlimited place of items on/off to a player
     *
     * @param Player $player
     * @param bool $mode
     * @return bool
     */
    public function setUnlimited(Player $player, bool $mode): bool{
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerUnlimitedModeChangeEvent($this, $player, $mode));
        if($ev->isCancelled()){
            return false;
        }
        $this->getSession($player)->setUnlimited($ev->getUnlimitedMode());
        return true;
    }

    /**
     * Automatically switch the state of the Unlimited mode
     *
     * @param Player $player
     */
    public function switchUnlimited(Player $player){
        $this->setUnlimited($player, !$this->isUnlimitedEnabled($player));
    }

    /**  _    _           _       _
     *  | |  | |         | |     | |
     *  | |  | |_ __   __| | __ _| |_ ___ _ __
     *  | |  | | '_ \ / _` |/ _` | __/ _ | '__|
     *  | |__| | |_) | (_| | (_| | ||  __| |
     *   \____/| .__/ \__,_|\__,_|\__\___|_|
     *         | |
     *         |_|
     */

    /** @var UpdateFetchTask */
    private $updaterTask = null;

    /** @var UpdateInstallTask */
    public $updaterDownloadTask = null; // Used to prevent Async Task conflicts with Server's limit :P

    /**
     * Tell if the auto-updater is enabled or not
     *
     * @return bool
     */
    public function isUpdaterEnabled(): bool{
        return $this->getEssentialsPEPlugin()->getConfig()->getNested("updater.enabled");
    }

    /**
     * Tell the build of the updater for EssentialsPE
     *
     * @return string
     */
    public function getUpdateBuild(): string{
        return $this->getEssentialsPEPlugin()->getConfig()->getNested("updater.channel", "stable");
    }

    /**
     * Get the interval for the updater to get in action
     *
     * @return int
     */
    public function getUpdaterInterval(): int{
        return $this->getEssentialsPEPlugin()->getConfig()->getNested("updater.time-interval");
    }

    /**
     * Get the latest version, and install it if you want
     *
     * @param bool $install
     * @return bool
     */
    public function fetchEssentialsPEUpdate(bool $install = false): bool{
        if(($this->updaterTask !== null && $this->updaterTask->isRunning()) && ($this->updaterDownloadTask !== null && $this->updaterDownloadTask->isRunning())){
            return false;
        }
        $this->getServer()->getLogger()->debug(TextFormat::YELLOW . "Running EssentialsPE's UpdateFetchTask");
        $this->getServer()->getScheduler()->scheduleAsyncTask($task = new UpdateFetchTask($this->getUpdateBuild(), $install));
        $this->updaterTask = $task;
        return true;
    }

    /**
     * Schedules the updater task :3
     */
    public function scheduleUpdaterTask(){
        if($this->isUpdaterEnabled()){
            $this->getServer()->getScheduler()->scheduleDelayedTask(new AutoFetchCallerTask($this), $this->getUpdaterInterval() * 20);
        }
    }

    /**
     * Warn about a new update of EssentialsPE
     *
     * @param string $message
     */
    public function broadcastUpdateAvailability(string $message){
        if($this->getEssentialsPEPlugin()->getConfig()->getNested("updater.warn-console")){
            $this->getServer()->getLogger()->info($message);
        }
        if($this->getEssentialsPEPlugin()->getConfig()->getNested("updater.warn-players")){
            foreach($this->getServer()->getOnlinePlayers() as $p){
                if($p->hasPermission("essentials.update.notify")){
                    $p->sendMessage($message);
                }
            }
        }
    }

    /** __      __         _     _
     *  \ \    / /        (_)   | |
     *   \ \  / __ _ _ __  _ ___| |__
     *    \ \/ / _` | '_ \| / __| '_ \
     *     \  | (_| | | | | \__ | | | |
     *      \/ \__,_|_| |_|_|___|_| |_|
     */

    /** @var null|Effect */
    private $invisibilityEffect = null;

    /**
     * Tell if a player is Vanished, or not
     *
     * @param Player $player
     * @return bool
     */
    public function isVanished(Player $player): bool{
        return $this->getSession($player)->isVanished();
    }

    /**
     * Tells if the specified player has "noPacket" enabled for vanish
     *
     * @param Player $player
     * @return bool
     */
    public function hasNoPacket(Player $player): bool{
        return $this->getSession($player)->noPacket();
    }

    /**
     * Set the Vanish mode on or off
     *
     * @param Player $player
     * @param bool $state
     * @param bool $noPacket
     * @return bool
     */
    public function setVanish(Player $player, bool $state, bool $noPacket = false): bool{
        if($this->invisibilityEffect === null){
            $effect = new Effect(Effect::INVISIBILITY, "Vanish", 127, 131, 146);
            $effect->setDuration(PHP_INT_MAX);
            $this->invisibilityEffect = $effect;
        }
        $this->getServer()->getPluginManager()->callEvent($ev = new PlayerVanishEvent($this, $player, $state, $noPacket));
        if($ev->isCancelled()){
            return false;
        }
        $state = $ev->willVanish();
        $player->setDataFlag(Entity::DATA_FLAGS, Entity::DATA_FLAG_INVISIBLE, $state);
        $player->setNameTagVisible(!$state);
        /** @var Player[] $pl */
        $pl = [];
        foreach($player->getLevel()->getPlayers() as $p){
            if($state || (!$state && !in_array($p->getName(), $ev->getHiddenFor()))){
                $pl[] = $p;
            }
        }
        $noPacket = $ev->noPacket();
        if($this->isVanished($player) && $ev->noPacket() !== ($priority = $this->hasNoPacket($player))){
            $noPacket = $priority;
        }
        if(!$noPacket){
            if(!$state){
                $pk = new MobEffectPacket();
                $pk->eid = $player->getId();
                $pk->eventId = MobEffectPacket::EVENT_REMOVE;
                $pk->effectId = $this->invisibilityEffect->getId();
            }else{
                $pk = new MobEffectPacket();
                $pk->eid = $player->getId();
                $pk->effectId = $this->invisibilityEffect->getId();
                $pk->amplifier = $this->invisibilityEffect->getAmplifier();
                $pk->particles = $this->invisibilityEffect->isVisible();
                $pk->duration = $this->invisibilityEffect->getDuration();
                $pk->eventId = MobEffectPacket::EVENT_ADD;
            }
            $this->getServer()->broadcastPacket($pl, $pk);
        }else{
            if(!$state){
                foreach($pl as $p){
                    $p->showPlayer($player);
                }
            }else{
                foreach($pl as $p){
                    $p->hidePlayer($player);
                }
            }
        }
        $this->getSession($player)->setVanish($state, !$state ? $ev->noPacket() : $noPacket);
        return true;
    }

    /**
     * Switch the Vanish mode on/off automatically
     *
     * @param Player $player
     * @return bool
     */
    public function switchVanish(Player $player): bool{
        $this->setVanish($player, !$this->isVanished($player));
        return true;
    }

    /**
     * Allow to switch between levels Vanished!
     * You need to teleport the player to a different level in order to call this event
     *
     * @param Player $player
     * @param Level $origin
     * @param Level $target
     */
    public function switchLevelVanish(Player $player, Level $origin, Level $target){
        if($origin !== $target && $this->isVanished($player)){

            // This will be used if the specified player has "noPacket" enabled.
            // A temporal check will be used for "the other players".
            $noPacket = $this->hasNoPacket($player);

            // Just as prevention if any player has "noPacket" disabled...
            $pk = new MobEffectPacket();
            $pk->effectId = $this->invisibilityEffect->getId();
            $pk->amplifier = $this->invisibilityEffect->getAmplifier();
            $pk->particles = $this->invisibilityEffect->isVisible();
            $pk->duration = $this->invisibilityEffect->getDuration();

            // Show to origin's players
            $pk->eventId = MobEffectPacket::EVENT_REMOVE;
            foreach($origin->getPlayers() as $p){
                if($p !== $player){
                    if($this->isVanished($player)){
                        if(!$noPacket){
                            $pk->eid = $player->getId();
                            $p->dataPacket($pk);
                        }else{
                            $p->showPlayer($player);
                        }
                    }
                    if($this->isVanished($p)){
                        if(!$this->hasNoPacket($p)){
                            $pk->eid = $p->getId();
                            $player->dataPacket($pk);
                        }else{
                            $player->showPlayer($p);
                        }
                    }
                }
            }
            // Hide to target's players
            $pk->eventId = MobEffectPacket::EVENT_ADD;
            foreach($target->getPlayers() as $p){
                if($p !== $player){
                    if($this->isVanished($player)){
                        if(!$noPacket){
                            $pk->eid = $player->getId();
                            $p->dataPacket($pk);
                        }else{
                            $p->hidePlayer($player);
                        }
                    }
                    if($this->isVanished($p)){
                        if(!$this->hasNoPacket($p)){
                            $pk->eid = $p->getId();
                            $player->dataPacket($pk);
                        }else{
                            $player->hidePlayer($p);
                        }
                    }
                }
            }
        }
    }

    /** __          __
     *  \ \        / /
     *   \ \  /\  / __ _ _ __ _ __
     *    \ \/  \/ / _` | '__| '_ \
     *     \  /\  | (_| | |  | |_) |
     *      \/  \/ \__,_|_|  | .__/
     *                       | |
     *                       |_|
     */

    /**
     * Tell if a warp exists
     *
     * @param string $warp
     * @return bool
     */
    public function warpExists(string $warp): bool{
        return $this->validateName($warp, false) && isset($this->warps[$warp]);
    }

    /**
     * Get a Location object of the warp
     * If the function returns "false", it means that the warp doesn't exists
     *
     * @param string $warp
     * @return bool|BaseLocation
     */
    public function getWarp(string $warp){
        if(!$this->warpExists($warp)){
            return false;
        }
        return $this->warps[$warp];
    }

    /**
     * Create a warp or override its position
     *
     * @param string $warp
     * @param Position $pos
     * @param float $yaw
     * @param float $pitch
     * @return bool
     */
    public function setWarp($warp, Position $pos, float $yaw = 0.0, float $pitch = 0.0): bool{
        if(!$this->validateName($warp, false)){
            return false;
        }
        $this->warps[$warp] = $pos instanceof BaseLocation ? $pos : BaseLocation::fromPosition($warp, ($pos instanceof Location ? $pos : Location::fromObject($pos, $pos->getLevel(), $yaw, $pitch)));
        return true;
    }

    /**
     * Removes a warp!
     * If the function return "false", it means that the warp doesn't exists
     *
     * @param string $warp
     * @return bool
     */
    public function removeWarp(string $warp): bool{
        if(!$this->warpExists($warp)){
            return false;
        }
        unset($this->warps[$warp]);
        return true;
    }

    /**
     * Return a list of all the available warps
     *
     * @param bool $inArray
     * @return array|bool|string
     */
    public function warpList(bool $inArray = false){
        $list = array_keys($this->warps);
        if(count($list) < 1){
            return false;
        }
        if(!$inArray){
            return implode(", ", $list);
        }
        return $list;
    }
}
<?php
namespace EssentialsPE\BaseFiles;

use pocketmine\level\Level;
use pocketmine\level\Location;

class BaseLocation extends Location{
    /** @var string */
    protected $name;

    /**
     * @param string $name
     * @param int $x
     * @param int $y
     * @param int $z
     * @param Level $level
     * @param float $yaw
     * @param float $pitch
     */
    public function __construct($name, $x, $y, $z, Level $level, $yaw, $pitch){
        parent::__construct($x, $y, $z, $yaw, $pitch, $level);
        $this->name = $name;
    }

    /**
     * @return string
     */
    public function getName(): string{
        return $this->name;
    }

    /**
     * @param $name
     * @param Location $pos
     * @return BaseLocation
     */
    public static function fromPosition($name, Location $pos): BaseLocation{
        return new BaseLocation($name, $pos->getX(), $pos->getY(), $pos->getZ(), $pos->getLevel(), $pos->getYaw(), $pos->getPitch());
    }
}<?php
namespace EssentialsPE\EventHandlers;

use EssentialsPE\BaseFiles\BaseEventHandler;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\entity\EntityExplodeEvent;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\server\ServerCommandEvent;
use pocketmine\math\Vector3;

class OtherEvents extends BaseEventHandler{
    /**
     * @param ServerCommandEvent $event
     */
    public function onServerCommand(ServerCommandEvent $event){
        $command = $this->getAPI()->colorMessage($event->getCommand());
        if($command === false){
            $event->setCancelled(true);
        }
        $event->setCommand($command);
    }

    /**
     * @param EntityExplodeEvent $event
     */
    public function onTNTExplode(EntityExplodeEvent $event){
        if($event->getEntity()->namedtag->getName() === "EssPE"){
            $event->setBlockList([]);
        }
    }

    /**
     * @param PlayerInteractEvent $event
     *
     * @priority HIGH
     */
    public function onBlockTap(PlayerInteractEvent $event){// PowerTool
        if($this->getAPI()->executePowerTool($event->getPlayer(), $event->getItem())){
            $event->setCancelled(true);
        }
    }

    /**
     * @param BlockPlaceEvent $event
     *
     * @priority HIGH
     */
    public function onBlockPlace(BlockPlaceEvent $event){
        // PowerTool
        if($this->getAPI()->executePowerTool($event->getPlayer(), $event->getItem())){
            $event->setCancelled(true);
        }

        // Unlimited block placing
        elseif($this->getAPI()->isUnlimitedEnabled($event->getPlayer())){
            $event->setCancelled(true);
            $pos = new Vector3($event->getBlockReplaced()->getX(), $event->getBlockReplaced()->getY(), $event->getBlockReplaced()->getZ());
            $event->getPlayer()->getLevel()->setBlock($pos, $event->getBlock(), true);
        }
    }
}<?php
namespace EssentialsPE\BaseFiles;

use EssentialsPE\Loader;
use pocketmine\event\Listener;

abstract class BaseEventHandler implements Listener{
    /** @var BaseAPI */
    private $api;

    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        $this->api = $api;
    }

    /**
     * @return Loader
     */
    public final function getPlugin(): Loader{
        return $this->getAPI()->getEssentialsPEPlugin();
    }

    /**
     * @return BaseAPI
     */
    public final function getAPI(): BaseAPI{
        return $this->api;
    }
}<?php

namespace EssentialsPE\EventHandlers;

use EssentialsPE\BaseFiles\BaseEventHandler;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityLevelChangeEvent;
use pocketmine\event\entity\EntityTeleportEvent;
use pocketmine\event\player\PlayerBedEnterEvent;
use pocketmine\event\player\PlayerChatEvent;
use pocketmine\event\player\PlayerCommandPreprocessEvent;
use pocketmine\event\player\PlayerDeathEvent;
use pocketmine\event\player\PlayerJoinEvent;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\event\player\PlayerPreLoginEvent;
use pocketmine\event\player\PlayerQuitEvent;
use pocketmine\event\TextContainer;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class PlayerEvents extends BaseEventHandler{
    /**
     * @param PlayerPreLoginEvent $event
     *
     * @priority MONITOR
     * @ignoreCancelled true
     */
    public function onPlayerPreLogin(PlayerPreLoginEvent $event){
        // Ban remove:
        if($event->getPlayer()->isBanned() && $event->getPlayer()->hasPermission("essentials.ban.exempt")){
            $event->getPlayer()->setBanned(false);
        }
    }

    /**
     * @param PlayerJoinEvent $event
     */
    public function onPlayerJoin(PlayerJoinEvent $event){
        // Player session creation:
        $this->getAPI()->createSession($event->getPlayer());
        $message = $event->getJoinMessage();
        if($message instanceof TranslationContainer){
            foreach($message->getParameters() as $i => $m){
                $message->setParameter($i, str_replace($event->getPlayer()->getName(), $event->getPlayer()->getDisplayName(), $m));
            }
        }elseif($message instanceof TextContainer){
            $message->setText(str_replace($event->getPlayer()->getName(), $event->getPlayer()->getDisplayName(), $message->getText()));
        }else{
            $message = str_replace($event->getPlayer()->getName(), $event->getPlayer()->getDisplayName(), $message);
        }
        $event->setJoinMessage($message);

        // Hide vanished players with "noPacket"
        foreach($event->getPlayer()->getServer()->getOnlinePlayers() as $p){
            if($this->getAPI()->isVanished($p) && $this->getAPI()->hasNoPacket($p)){
                $event->getPlayer()->hidePlayer($p);
            }
        }
        $i = $this->getAPI()->getMutedUntil($event->getPlayer());
        if($i instanceof \DateTime && $event->getPlayer()->hasPermission("essentials.mute.notify")){
            $event->getPlayer()->sendMessage(TextFormat::YELLOW . "Remember that you're muted until " . TextFormat::AQUA . $i->format("l, F j, Y") . TextFormat::YELLOW . " at " . TextFormat::AQUA . $i->format("h:ia"));
        }
        //$this->getAPI()->setPlayerBalance($event->getPlayer(), $this->getAPI()->getDefaultBalance()); TODO
    }

    /**
     * @param PlayerQuitEvent $event
     */
    public function onPlayerQuit(PlayerQuitEvent $event){
        // Quit message (nick):
        $message = $event->getQuitMessage();
        if($message instanceof TranslationContainer){
            foreach($message->getParameters() as $i => $m){
                $message->setParameter($i, str_replace($event->getPlayer()->getName(), $event->getPlayer()->getDisplayName(), $m));
            }
        }elseif($message instanceof TextContainer){
            $message->setText(str_replace($event->getPlayer()->getName(), $event->getPlayer()->getDisplayName(), $message->getText()));
        }else{
            $message = str_replace($event->getPlayer()->getName(), $event->getPlayer()->getDisplayName(), $message);
        }
        $event->setQuitMessage($message);

        // Session destroy:
        if($this->getAPI()->sessionExists($event->getPlayer())){
            $this->getAPI()->removeSession($event->getPlayer());
        }
    }

    /**
     * @param PlayerChatEvent $event
     */
    public function onPlayerChat(PlayerChatEvent $event){
        if($this->getAPI()->isMuted($event->getPlayer())){
            if($event->getPlayer()->hasPermission("essentials.mute.exempt")){
                $this->getAPI()->setMute($event->getPlayer(), false, null, false);
            }elseif(($t = $this->getAPI()->getMutedUntil($event->getPlayer())) === null){
                $event->setCancelled(true);
            }else{
                $t2 = new \DateTime();
                if($t < $t2){
                    $this->getAPI()->setMute($event->getPlayer(), false, null, false);
                }else{
                    $event->setCancelled(true);
                }
            }
        }elseif($this->getAPI()->isAFK($event->getPlayer())){
            $this->getAPI()->setAFKMode($event->getPlayer(), false, true);
        }
    }

    /**
     * @param PlayerCommandPreprocessEvent $event
     */
    public function onPlayerCommand(PlayerCommandPreprocessEvent $event){
        $command = $this->getAPI()->colorMessage($event->getMessage(), $event->getPlayer());
        if($command === false){
            $event->setCancelled(true);
        }
        $event->setMessage($command);
    }

    /**
     * @param PlayerMoveEvent $event
     */
    public function onPlayerMove(PlayerMoveEvent $event){
        $entity = $event->getPlayer();
        if($this->getAPI()->isAFK($entity)){
            $this->getAPI()->setAFKMode($entity, false, true);
        }

        $this->getAPI()->setLastPlayerMovement($entity, time());
    }

    /**
     * @param EntityTeleportEvent $event
     */
    public function onEntityTeleport(EntityTeleportEvent $event){
        $entity = $event->getEntity();
        if($entity instanceof Player){
            $this->getAPI()->setPlayerLastPosition($entity, $entity->getLocation());
        }
    }

    /**
     * @param EntityLevelChangeEvent $event
     *
     * @priority MONITOR
     */
    public function onEntityLevelChange(EntityLevelChangeEvent $event){
        $entity = $event->getEntity();
        if($entity instanceof Player){
            $this->getAPI()->switchLevelVanish($entity, $event->getOrigin(), $event->getTarget());
        }
    }

    /**
     * @param PlayerBedEnterEvent $event
     */
    public function onPlayerSleep(PlayerBedEnterEvent $event){
        if($event->getPlayer()->hasPermission("essentials.home.bed")){
            $this->getAPI()->setHome($event->getPlayer(), "bed", $event->getPlayer()->getPosition());
        }
    }

    /**
     * @param EntityDamageEvent $event
     *
     * @priority HIGH
     */
    public function onEntityDamageByEntity(EntityDamageEvent $event){
        $victim = $event->getEntity();
        if($victim instanceof Player){
            if($this->getAPI()->isGod($victim) || ($this->getAPI()->isAFK($victim)) && $this->getPlugin()->getConfig()->getNested("afk.safe")){
                $event->setCancelled(true);
            }

            if($event instanceof EntityDamageByEntityEvent){
                $issuer = $event->getDamager();
                if($issuer instanceof Player){
                    if(!($s = $this->getAPI()->isPvPEnabled($issuer)) || !$this->getAPI()->isPvPEnabled($victim)){
                        $issuer->sendMessage(TextFormat::RED . (!$s ? "You have" : $victim->getDisplayName() . " has") . " PvP disabled!");
                        $event->setCancelled(true);
                    }

                    if($this->getAPI()->isGod($issuer) && !$issuer->hasPermission("essentials.god.pvp")){
                        $event->setCancelled(true);
                    }

                    if($this->getAPI()->isVanished($issuer) && !$issuer->hasPermission("essentials.vanish.pvp")){
                        $event->setCancelled(true);
                    }
                }
            }
        }
    }

    /**
     * @param PlayerDeathEvent $event
     */
    public function onPlayerDeath(PlayerDeathEvent $event){
        if($event->getEntity()->hasPermission("essentials.back.ondeath")){
            $this->getAPI()->setPlayerLastPosition($event->getEntity(), $event->getEntity()->getLocation());
        }else{
            $this->getAPI()->removePlayerLastPosition($event->getEntity());
        }
    }
}
<?php

namespace EssentialsPE\EventHandlers;

use EssentialsPE\BaseFiles\BaseEventHandler;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\SignChangeEvent;
use pocketmine\event\entity\EntityRegainHealthEvent;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\math\Vector3;
use pocketmine\tile\Sign;
use pocketmine\utils\TextFormat;

class SignEvents extends BaseEventHandler{
    /**
     * @param PlayerInteractEvent $event
     */
    public function onSignTap(PlayerInteractEvent $event){
        $tile = $event->getBlock()->getLevel()->getTile(new Vector3($event->getBlock()->getFloorX(), $event->getBlock()->getFloorY(), $event->getBlock()->getFloorZ()));
        if($tile instanceof Sign){
            // Free sign
            if(TextFormat::clean($tile->getText()[0], true) === "[Free]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.free")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
               }else{
                    if($event->getPlayer()->getGamemode() === 1 || $event->getPlayer()->getGamemode() === 3){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You're in " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . " mode");
                        return;
                    }

                    $item_name = $tile->getText()[1];
                    $damage = $tile->getText()[2];

                    $item = $this->getAPI()->getItem($item_name . ":" . $damage);

                    $event->getPlayer()->getInventory()->addItem($item);
                    $event->getPlayer()->sendMessage(TextFormat::YELLOW . "Giving " . TextFormat::RED . $item->getCount() . TextFormat::YELLOW . " of " . TextFormat::RED . ($item->getName() === "Unknown" ? $item_name : $item->getName()));
                }
            }

            // Gamemode sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Gamemode]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.gamemode")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
               }else{
                    $v = strtolower($tile->getText()[1]);
                    $price = substr($tile->getText()[2], 7);
                    if($price !== false) {
                        if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                            $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                            return;
                        } else {
                            $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                        }
                    }
                    if($v === "survival"){
                        $event->getPlayer()->setGamemode(0);
                    }elseif($v === "creative"){
                        $event->getPlayer()->setGamemode(1);
                    }elseif($v === "adventure"){
                        $event->getPlayer()->setGamemode(2);
                    }elseif($v === "spectator"){
                        $event->getPlayer()->setGamemode(3);
                    }
                    $event->getPlayer()->sendMessage(TextFormat::GREEN . "Your gamemode has been set to " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : null));
                }
            }

            // Heal sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Heal]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.heal")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                }elseif($event->getPlayer()->getGamemode() === 1 || $event->getPlayer()->getGamemode() === 3){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You're in " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . " mode");
                    return;
               }else{
                    $price = substr($tile->getText()[1], 7);
                    if($price !== false) {
                        if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                            $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                            return;
                        } else {
                            $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                        }
                    }
                    $event->getPlayer()->heal($event->getPlayer()->getMaxHealth(), new EntityRegainHealthEvent($event->getPlayer(), $event->getPlayer()->getMaxHealth(), EntityRegainHealthEvent::CAUSE_CUSTOM));
                    $event->getPlayer()->sendMessage(TextFormat::GREEN . "You have been healed" . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : null));
                }
            }
            
            // Kit sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Kit]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.kit")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                }elseif($event->getPlayer()->getGamemode() === 1 || $event->getPlayer()->getGamemode() === 3){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You're in " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . " mode");
                    return;
                }else{
                    if(!($kit = $this->getAPI()->getKit($tile->getText()[1]))){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Kit doesn't exists");
                        return;
                    }elseif(!$event->getPlayer()->hasPermission("essentials.kits." . $kit->getName())){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have permissions to get this kit");
                        return;
                    }else{
                        $price = substr($tile->getText()[2], 7);
                        if($price !== false) {
                            if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                                return;
                            } else {
                                $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                            }
                        }
                        $kit->giveToPlayer($event->getPlayer());
                        $event->getPlayer()->sendMessage(TextFormat::GREEN . "Getting kit " . TextFormat::AQUA . $kit->getName() . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : "..."));
                    }
                }
            }

            // Repair sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Repair]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.repair")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                }elseif($event->getPlayer()->getGamemode() === 1 || $event->getPlayer()->getGamemode() === 3){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You're in " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . " mode");
                    return;
               }else{
                    if(($v = $tile->getText()[1]) === "Hand"){
                        $price = substr($tile->getText()[2], 7);
                        if($price !== false) {
                            if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                                return;
                            } else {
                                $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                            }
                        }
                        if($this->getAPI()->isRepairable($item = $event->getPlayer()->getInventory()->getItemInHand())){
                            $item->setDamage(0);
                            $event->getPlayer()->sendMessage(TextFormat::GREEN . "Item successfully repaired" . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : null));
                        }
                    }elseif($v === "All"){
                        $price = substr($tile->getText()[2], 7);
                        if($price !== false) {
                            if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                                return;
                            } else {
                                $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                            }
                        }
                        foreach ($event->getPlayer()->getInventory()->getContents() as $item){
                            if($this->getAPI()->isRepairable($item)){
                                $item->setDamage(0);
                            }
                        }
                        foreach ($event->getPlayer()->getInventory()->getArmorContents() as $item){
                            if($this->getAPI()->isRepairable($item)){
                                $item->setDamage(0);
                            }
                        }
                        $event->getPlayer()->sendMessage(TextFormat::GREEN . "All the tools on your inventory were repaired" . TextFormat::AQUA . "\n(including the equipped Armor)" . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : null));
                    }
                }
            }

            // Time sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Time]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.time")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
               }else{
                    if(($v = $tile->getText()[1]) === "Day"){
                        $price = substr($tile->getText()[2], 7);
                        if($price !== false) {
                            if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                                return;
                            } else {
                                $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                            }
                        }
                        $event->getPlayer()->getLevel()->setTime(0);
                        $event->getPlayer()->sendMessage(TextFormat::GREEN . "Time set to \"Day\"" . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : null));
                    }elseif($v === "Night"){
                        $price = substr($tile->getText()[2], 7);
                        if($price !== false) {
                            if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                                return;
                            } else {
                                $this->getAPI()->addToPlayerBalance($event->getPlayer(), $price);
                            }
                        }
                        $event->getPlayer()->getLevel()->setTime(12500);
                        $event->getPlayer()->sendMessage(TextFormat::GREEN . "Time set to \"Night\"" . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : null));
                    }
                }
            }

            // Teleport sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Teleport]"){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.teleport")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
               }else{
                    $event->getPlayer()->teleport(new Vector3($x = $tile->getText()[1], $y = $tile->getText()[2], $z = $tile->getText()[3]));
                    $event->getPlayer()->sendMessage(TextFormat::GREEN . "Teleporting to " . TextFormat::AQUA . $x . TextFormat::GREEN . ", " . TextFormat::AQUA . $y . TextFormat::GREEN . ", " . TextFormat::AQUA . $z);
                }
            }

            // Warp sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Warp]" && $this->getAPI()->getEssentialsPEPlugin()->getServer()->getPluginManager()->getPlugin("SimpleWarp") === null && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("warps") === true){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.warp")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
               }else{
                    $warp = $this->getAPI()->getWarp($tile->getText()[1]);
                    if(!$warp){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Warp doesn't exists");
                        return;
                    }
                    if(!$event->getPlayer()->hasPermission("essentials.warps.*") && !$event->getPlayer()->hasPermission("essentials.warps." . $tile->getText()[1])){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You can't teleport to that warp");
                        return;
                    }
                    $price = substr($tile->getText()[2], 7);
                    if($price !== false) {
                        if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                            $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to use this sign");
                            return;
                        } else {
                            $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                        }
                    }
                    $event->getPlayer()->teleport($warp);
                    $event->getPlayer()->sendMessage(TextFormat::GREEN . "Warping to " . $tile->getText()[1] . TextFormat::GREEN . ($price ? " for " . $this->getAPI()->getCurrencySymbol() . $price : "..."));
                }
            }

            /*
             * Economy Signs
             */
            
            // Balance sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Balance]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.balance")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                }else{
                    $event->getPlayer()->sendMessage(TextFormat::AQUA . "Your current balance is " . TextFormat::YELLOW . $this->getAPI()->getCurrencySymbol() . $this->getAPI()->getPlayerBalance($event->getPlayer()));
                }
            }

            // BalanceTop sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[BalanceTop]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.balancetop")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                }else{
                    $event->getPlayer()->sendMessage(TextFormat::GREEN . " --- Balance Top --- ");
                    $this->getAPI()->sendBalanceTop($event->getPlayer());
                }
            }
            
            // Buy sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Buy]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.buy")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                } else {
                    if($event->getPlayer()->getGamemode() === 1 || $event->getPlayer()->getGamemode() === 3){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You're in " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . " mode");
                        return;
                    }

                    $item_name = $tile->getText()[1];
                    $amount = (int)substr($tile->getText()[2], 8);
                    $item = $this->getAPI()->getItem($item_name);
                    $item->setCount($amount);
                    $price = (int)substr($tile->getText()[3], 7);
                    if(!$this->getAPI()->hasPlayerBalance($event->getPlayer(), $price)) {
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have enough money to buy this item!");
                        return;
                    }
                    $this->getAPI()->addToPlayerBalance($event->getPlayer(), -$price);
                    $event->getPlayer()->getInventory()->addItem($item);
                    $event->getPlayer()->sendMessage(TextFormat::YELLOW . "You have bought " . TextFormat::RED . $amount . TextFormat::YELLOW . " of " . TextFormat::RED . ($item->getName() === "Unknown" ? $item_name : $item->getName()) . TextFormat::YELLOW . " for " . TextFormat::RED . $price . $this->getAPI()->getCurrencySymbol());
                }
            }
            
            // Sell sign
            elseif(TextFormat::clean($tile->getText()[0], true) === "[Sell]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true){
                $event->setCancelled(true);
                if(!$event->getPlayer()->hasPermission("essentials.sign.use.sell")){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to use this sign");
                } else {
                    if($event->getPlayer()->getGamemode() === 1 || $event->getPlayer()->getGamemode() === 3){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You're in " . $event->getPlayer()->getServer()->getGamemodeString($event->getPlayer()->getGamemode()) . " mode");
                        return;
                    }

                    $item_name = $tile->getText()[1];
                    $amount = (int)substr($tile->getText()[2], 8);
                    $item = $this->getAPI()->getItem($item_name);
                    $item->setCount($amount);
                    $price = (int)substr($tile->getText()[3], 7);
                    if(!$event->getPlayer()->getInventory()->contains($item)) {
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You don't have this item in your inventory!");
                        return;
                    }
                    $this->getAPI()->addToPlayerBalance($event->getPlayer(), $price);
                    $event->getPlayer()->getInventory()->removeItem($item);
                    $event->getPlayer()->sendMessage(TextFormat::YELLOW . "You have sold " . TextFormat::RED . $amount . TextFormat::YELLOW . " of " . TextFormat::RED . ($item->getName() === "Unknown" ? $item_name : $item->getName()) . TextFormat::YELLOW . " for " . TextFormat::RED . $price . $this->getAPI()->getCurrencySymbol());
                }
            }
        }
    }

    /**
     * @param BlockBreakEvent $event
     *
     * @priority HIGH
     */
    public function onBlockBreak(BlockBreakEvent $event){
        $tile = $event->getBlock()->getLevel()->getTile(new Vector3($event->getBlock()->getFloorX(), $event->getBlock()->getFloorY(), $event->getBlock()->getFloorZ()));
        if($tile instanceof Sign){
            $key = ["Free", "Gamemode", "Heal", "Kit", "Repair", "Time", "Teleport", "Warp", "Balance", "Buy", "Sell", "BalanceTop"];
            foreach($key as $k){
                if(TextFormat::clean($tile->getText()[0], true) === "[" . $k . "]" && !$event->getPlayer()->hasPermission("essentials.sign.break." . strtolower($k))){
                    $event->setCancelled(true);
                    $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permissions to break this sign");
                    break;
                }
            }
        }
    }

    /**
     * @param SignChangeEvent $event
     */
    public function onSignChange(SignChangeEvent $event){
        // Special Signs
        // Free sign
        if(strtolower(TextFormat::clean($event->getLine(0), true)) === "[free]" && $event->getPlayer()->hasPermission("essentials.sign.create.free")){
            if(trim($event->getLine(1)) !== "" || $event->getLine(1) !== null){
                $item_name = $event->getLine(1);

                if(trim($event->getLine(2)) !== "" || $event->getLine(2) !== null){
                    $damage = $event->getLine(2);
                }else{
                    $damage = 0;
                }

                $item = $this->getAPI()->getItem($item_name . ":" . $damage);

                if($item->getId() === 0 || $item->getName() === "Air"){
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid item name/ID");
                    $event->setCancelled(true);
                }else{
                    $event->getPlayer()->sendMessage(TextFormat::GREEN . "Free sign successfully created!");
                    $event->setLine(0, TextFormat::AQUA . "[Free]");
                    $event->setLine(1, ($item->getName() === "Unknown" ? $item->getId() : $item->getName()));
                    $event->setLine(2, $damage);
                }
            }else{
                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You should provide an item name/ID");
                $event->setCancelled(true);
            }
        }

        // Gamemode sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[gamemode]" && $event->getPlayer()->hasPermission("essentials.sign.create.gamemode")){
            switch(strtolower($event->getLine(1))){
                case "survival":
                case "0":
                    $event->setLine(1, "Survival");
                    break;
                case "creative":
                case "1":
                    $event->setLine(1, "Creative");
                    break;
                case "adventure":
                case "2":
                    $event->setLine(1, "Adventure");
                    break;
                case "spectator":
                case "view":
                case "3":
                    $event->setLine(1, "Spectator");
                    break;
                default:
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Unknown Gamemode, you should use \"Survival\", \"Creative\", \"Adventure\" or \"Spectator\"");
                    $event->setCancelled(true);
                    return;
            }
            $event->getPlayer()->sendMessage(TextFormat::GREEN . "Gamemode sign successfully created!");
            $event->setLine(0, TextFormat::AQUA . "[Gamemode]");
            $price = $event->getLine(2);
            if(is_numeric($price) && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
                $event->setLine(2, "Price: " . $price);
            }
        }

        // Heal sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[heal]" && $event->getPlayer()->hasPermission("essentials.sign.create.heal")){
            $event->getPlayer()->sendMessage(TextFormat::GREEN . "Heal sign successfully created!");
            $event->setLine(0, TextFormat::AQUA . "[Heal]");
            $price = $event->getLine(1);
            if(is_numeric($price) && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
                $event->setLine(1, "Price: " . $price);
            }
        }

        // Kit sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[kit]" && $event->getPlayer()->hasPermission("essentials.sign.create.kit")){
            if(!$this->getAPI()->kitExists($event->getLine(1))){
                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Kit doesn't exist");
                return;
            }
            $event->getPlayer()->sendMessage(TextFormat::GREEN . "Kit sign successfully created!");
            $event->setLine(0, TextFormat::AQUA . "[Kit]");
            $price = $event->getLine(2);
            if(is_numeric($price)) {
                $event->setLine(2, "Price: " . $price);
            }
        }

        // Repair sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[repair]" && $event->getPlayer()->hasPermission("essentials.sign.create.repair")){
            switch(strtolower($event->getLine(1))){
                case "hand":
                    $event->setLine(1, "Hand");
                    break;
                case "all":
                    $event->setLine(1, "All");
                    break;
                default:
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid argument, you should use \"Hand\" or \"All\"");
                    $event->setCancelled(true);
                    return;
            }
            $event->getPlayer()->sendMessage(TextFormat::GREEN . "Repair sign successfully created!");
            $event->setLine(0, TextFormat::AQUA . "[Repair]");
            $price = $event->getLine(2);
            if(is_numeric($price) && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
                $event->setLine(2, "Price: " . $price);
            }
        }

        // Time sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[time]" && $event->getPlayer()->hasPermission("essentials.sign.create.time")){
            switch(strtolower($event->getLine(1))){
                case "day":
                    $event->setLine(1, "Day");
                    break;
                case "night";
                    $event->setLine(1, "Night");
                    break;
                default:
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid time, you should use \"Day\" or \"Night\"");
                    $event->setCancelled(true);
                    return;
            }
            $event->getPlayer()->sendMessage(TextFormat::GREEN . "Time sign successfully created!");
            $event->setLine(0, TextFormat::AQUA . "[Time]");
            $price = $event->getLine(2);
            if(is_numeric($price) && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
                $event->setLine(2, "Price: " . $price);
            }
        }

        // Teleport sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[teleport]" && $event->getPlayer()->hasPermission("essentials.sign.create.teleport")){
            if(!is_numeric($event->getLine(1))){
                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid X position, Teleport sign will not work");
                $event->setCancelled(true);
            }elseif(!is_numeric($event->getLine(2))){
                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid Y position, Teleport sign will not work");
                $event->setCancelled(true);
            }elseif(!is_numeric($event->getLine(3))){
                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid Z position, Teleport sign will not work");
                $event->setCancelled(true);
            }else{
                $event->getPlayer()->sendMessage(TextFormat::GREEN . "Teleport sign successfully created!");
                $event->setLine(0, TextFormat::AQUA . "[Teleport]");
                $event->setLine(1, $event->getLine(1));
                $event->setLine(2, $event->getLine(2));
                $event->setLine(3, $event->getLine(3));
            }
        }

        // Warp sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[warp]" && $event->getPlayer()->hasPermission("essentials.sign.create.warp") && $this->getAPI()->getEssentialsPEPlugin()->getServer()->getPluginManager()->getPlugin("SimpleWarp") === null && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("warps") === true){
            $warp = $event->getLine(1);
            if(!$this->getAPI()->warpExists($warp)){
                $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Warp doesn't exists");
                $event->setCancelled(true);
            }else{
                $event->getPlayer()->sendMessage(TextFormat::GREEN . "Warp sign successfully created!");
                $event->setLine(0, TextFormat::AQUA . "[Warp]");
                $price = $event->getLine(2);
                if(is_numeric($price) && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
                    $event->setLine(2, "Price: " . $price);
                }
            }
        }

        /*
         * Economy signs
         */

        // BalanceTop sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[balancetop]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
            if($event->getPlayer()->hasPermission("essentials.sign.create.balancetop")) {
                $event->setLine(0, TextFormat::AQUA . "[BalanceTop]");
                $event->getPlayer()->sendMessage(TextFormat::GREEN . "BalanceTop sign succesfully created!");
            } else {
                $event->setCancelled(true);
                $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permission to create this sign!");
            }
        }
        
        // Balance sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[balance]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true) {
            if($event->getPlayer()->hasPermission("essentials.sign.create.balance")) {
                $event->setLine(0, TextFormat::AQUA . "[Balance]");
                $event->getPlayer()->sendMessage(TextFormat::GREEN . "Balance sign successfully created!");
            } else {
                $event->setCancelled(true);
                $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permission to create this sign!");
            }
        }
        
        // Buy sign
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[buy]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true){
            if($event->getPlayer()->hasPermission("essentials.sign.create.buy")) {
                if(trim($event->getLine(1)) !== "" || $event->getLine(1) !== null){
                    $item_name = $event->getLine(1);
                    if(($amount = $event->getLine(2)) == null) {
                        $amount = 1;
                    }
                
                    if(($price = $event->getLine(3)) == null) {
                        $price = 1;
                    }

                    $item = $this->getAPI()->getItem($item_name);

                    if($item->getId() === 0 || $item->getName() === "Air"){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid item name/ID");
                        $event->setCancelled(true);
                    } else {
                        $event->getPlayer()->sendMessage(TextFormat::GREEN . "Buy sign successfully created!");
                        $event->setLine(0, TextFormat::AQUA . "[Buy]");
                        $event->setLine(1, ($item->getName() === "Unknown" ? $item->getId() : $item->getName()));
                        $event->setLine(2, "Amount: " . $amount);
                        $event->setLine(3, "Price: " . $price);
                    }
                }else{
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You should provide an item name/ID");
                    $event->setCancelled(true);
                }
            } else {
                $event->setCancelled(true);
                $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permission to create this sign!");
            }
        }
        
        elseif(strtolower(TextFormat::clean($event->getLine(0), true)) === "[sell]" && $this->getAPI()->getEssentialsPEPlugin()->getConfig()->get("economy") === true){
            if($event->getPlayer()->hasPermission("essentials.sign.create.sell")) {
                if(trim($event->getLine(1)) !== "" || $event->getLine(1) !== null){
                    $item_name = $event->getLine(1);
                    if(($amount = $event->getLine(2)) == null) {
                        $amount = 1;
                    }
                    
                    if(($price = $event->getLine(3)) == null) {
                        $price = 1;
                    }
                
                    $item = $this->getAPI()->getItem($item_name);

                    if($item->getId() === 0 || $item->getName() === "Air"){
                        $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] Invalid item name/ID");
                        $event->setCancelled(true);
                    }else{
                        $event->getPlayer()->sendMessage(TextFormat::GREEN . "Sell sign successfully created!");
                        $event->setLine(0, TextFormat::AQUA . "[Sell]");
                        $event->setLine(1, ($item->getName() === "Unknown" ? $item->getId() : $item->getName()));
                        $event->setLine(2, "Amount: " . $amount);
                        $event->setLine(3, "Price: " . $price);
                    }
                }else{
                    $event->getPlayer()->sendMessage(TextFormat::RED . "[Error] You should provide an item name/ID");
                    $event->setCancelled(true);
                }
            } else {
                $event->setCancelled(true);
                $event->getPlayer()->sendMessage(TextFormat::RED . "You don't have permission to create this sign!");
            }
        }
        // Colored Sign
        elseif($event->getPlayer()->hasPermission("essentials.sign.color")){
            for($i = 0 ; $i < 4 ; $i++){
                $event->setLine($i, $this->getAPI()->colorMessage($event->getLine($i)));
            }
        }
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AFK extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "afk", "Toggle the \"Away From the Keyboard\" status", "[player]", true, ["away"]);
        $this->setPermission("essentials.afk.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!isset($args[0]) && !$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.afk.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $this->getAPI()->switchAFKMode($player, true);
        return true;
    }
} <?php
namespace EssentialsPE\BaseFiles;

use EssentialsPE\Loader;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

abstract class BaseCommand extends Command implements PluginIdentifiableCommand{
    /** @var BaseAPI  */
    private $api;
    /** @var bool|string */
    private $consoleUsageMessage;

    /**
     * @param BaseAPI $api
     * @param string $name
     * @param string $description
     * @param null|string $usageMessage
     * @param bool|null|string $consoleUsageMessage
     * @param array $aliases
     */
    public function __construct(BaseAPI $api, $name, $description = "", $usageMessage = null, $consoleUsageMessage = true, array $aliases = []){
        parent::__construct($name, $description, $usageMessage, $aliases);
        $this->api = $api;
        $this->consoleUsageMessage = $consoleUsageMessage;
    }

    /**
     * @return Loader
     */
    public final function getPlugin(): Loader{
        return $this->getAPI()->getEssentialsPEPlugin();
    }

    /**
     * @return BaseAPI
     */
    public final function getAPI(): BaseAPI{
        return $this->api;
    }

    /**
     * @return string
     */
    public function getUsage(): string{
        return "/" . parent::getName() . " " . parent::getUsage();
    }

    /**
     * @return bool|null|string
     */
    public function getConsoleUsage(){
        return $this->consoleUsageMessage;
    }

    /**
     * Function to give different type of usages, switching from "Console" and "Player" executors of a command.
     * This function can be overridden to fit any command needs...
     *
     * @param CommandSender $sender
     * @param string $alias
     */
    public function sendUsage(CommandSender $sender, string $alias){
        $message = TextFormat::RED . "Usage: " . TextFormat::GRAY . "/$alias ";
        if(!$sender instanceof Player){
            if(is_string($this->consoleUsageMessage)){
                $message .= $this->consoleUsageMessage;
            }elseif(!$this->consoleUsageMessage){
                $message = TextFormat::RED . "[Error] Please run this command in-game";
            }else{
                $message .= str_replace("[player]", "<player>", parent::getUsage());
            }
        }else{
            $message .= parent::getUsage();
        }
        $sender->sendMessage($message);
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Antioch extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "antioch", "Holy hand grenade", null, false, ["grenade", "tnt"]);
        $this->setPermission("essentials.antioch");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!$this->getAPI()->antioch($sender)){
            $sender->sendMessage(TextFormat::RED . "[Error] Couldn't throw the grenade, there wasn't a valid block near");
            return false;
        }
        $sender->sendMessage(TextFormat::GREEN . "Grenade thrown!");
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Back extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "back", "Teleport to your previous location", null, false, ["return"]);
        $this->setPermission("essentials.back.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($pos = $this->getAPI()->getLastPlayerPosition($sender))){
            $sender->sendMessage(TextFormat::RED . "[Error] No previous position available");
            return false;
        }
        $sender->sendMessage(TextFormat::GREEN . "Teleporting...");
        $sender->teleport($pos);
        return true;
    }
} <?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\block\Air;
use pocketmine\block\Block;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class BreakCommand extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "break", "Breaks the block you're looking at", null, false);
        $this->setPermission("essentials.break.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(($block = $sender->getTargetBlock(100, [Block::AIR])) === null){
            $sender->sendMessage(TextFormat::RED . "There isn't a reachable block");
            return false;
        }elseif($block->getId() === Block::BEDROCK && !$sender->hasPermission("essentials.break.bedrock")){
            $sender->sendMessage(TextFormat::RED . "You can't break bedrock");
            return false;
        }
        $sender->getLevel()->setBlock($block, new Air(), true, true);
        return true;
    }
} <?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class Broadcast extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "broadcast", "Broadcast a message", "<message>", true, ["bcast"]);
        $this->setPermission("essentials.broadcast");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) < 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $sender->getServer()->broadcastMessage(TextFormat::LIGHT_PURPLE . "[Broadcast] " . TextFormat::RESET . implode(" ", $args));
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class Burn extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "burn", "Set a player on fire", "<player> <seconds>");
        $this->setPermission("essentials.burn");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) != 2){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        if(!is_numeric($time = $args[1])){
            $sender->sendMessage(TextFormat::RED . "[Error] Invalid burning time");
            return false;
        }
        $player->setOnFire($time);
        $sender->sendMessage(TextFormat::YELLOW . $player->getDisplayName() . " is now on fire!");
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ClearInventory extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "clearinventory", "Clear your/other's inventory", "[player]", true, ["ci", "clean", "clearinvent"]);
        $this->setPermission("essentials.clearinventory.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) &&  !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.clearinventory.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if(($gm = $player->getGamemode()) === 1 || $gm === 3){
            $sender->sendMessage(TextFormat::RED . "[Error] " . (isset($args[0]) ? $player->getDisplayName() . "is" : "You are") . " in " . $this->getAPI()->getServer()->getGamemodeString($gm) . " mode");
            return false;
        }
        $player->getInventory()->clearAll();
        $player->sendMessage(TextFormat::AQUA . "Your inventory was cleared");
        if($player !== $sender){
            $sender->sendMessage(TextFormat::AQUA . $player->getDisplayName() . (substr($player->getDisplayName(), -1, 1) === "s" ? "'" : "'s") . " inventory was cleared");
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Compass extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "compass", "Display your current bearing direction", null, false, ["direction"]);
        $this->setPermission("essentials.compass");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        switch($sender->getDirection()){
            case 0:
                $direction = "south";
                break;
            case 1:
                $direction = "west";
                break;
            case 2:
                $direction = "north";
                break;
            case 3:
                $direction = "east";
                break;
            default:
                $sender->sendMessage(TextFormat::RED . "Oops, there was an error while getting your face direction");
                return false;
                break;
        }
        $sender->sendMessage(TextFormat::AQUA . "You're facing " . TextFormat::YELLOW . $direction);
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Condense extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "condense", "Compact your inventory!", "[item name|id|hand|inventory|all]", false, ["compact", "toblocks"]);
        $this->setPermission("essentials.condense");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!isset($args[0])){
            $args[0] = "inventory";
        }
        switch($args[0]){
            case "hand":
                $target = $sender->getInventory()->getItemInHand();
                break;
            case "inventory":
            case "all":
                $target = null;
                break;
            default: // Item name|id
                $target = $this->getAPI()->getItem($args[0]);
                if($target->getId() === 0){
                    $sender->sendMessage(TextFormat::RED . "Unknown item \"" . $args[0] . "\"");
                    return false;
                }
                break;
        }
        if(!$this->getAPI()->condenseItems($sender->getInventory(), $target)){
            $sender->sendMessage(TextFormat::RED . "[Error] This item can't be condensed");
        }
        $sender->sendMessage(TextFormat::YELLOW . "Condensing items...");
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Depth extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "depth", "Display your depth related to sea-level", null, false, ["height"]);
        $this->setPermission("essentials.depth");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $sender->sendMessage(TextFormat::AQUA . "You're " . (($pos = $sender->getFloorY() - 63) === 0 ? "at" : (abs($pos) . " meters " . ($pos > 0 ? "above" : "below"))) . " the sea level.");
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class EssentialsPE extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "essentials", "Get the current Essentials version", "[update <check|install>]", true, ["essentials", "ess", "esspe"]);
        $this->setPermission("essentials.essentials");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        switch(count($args)){
            case 0:
                $sender->sendMessage(TextFormat::YELLOW . "You're using " . TextFormat::AQUA . "EssentialsPE " . TextFormat::YELLOW . "v" . TextFormat::GREEN . $sender->getServer()->getPluginManager()->getPlugin("EssentialsPE")->getDescription()->getVersion());
                break;
            case 1:
            case 2:
                switch(strtolower($args[0])){
                    case "update":
                    case "u":
                        if(!$sender->hasPermission("essentials.update.use")){
                            $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                            return false;
                        }
                        if(isset($args[1]) && (($a = strtolower($args[1])) === "check" || $a === "c" || $a === "install" || $a === "i")){
                            if(!$this->getAPI()->fetchEssentialsPEUpdate($a[0] === "i")){
                                $sender->sendMessage(TextFormat::YELLOW . "The updater is already working... Please wait a few moments and try again");
                            }
                            return true;
                        }
                        $sender->sendMessage(TextFormat::RED . ($sender instanceof Player ? "" : "Usage: ") . "/essentialspe update <check|install>");
                        break;
                    case "version":
                    case "v":
                        $sender->sendMessage(TextFormat::YELLOW . "You're using " . TextFormat::AQUA . "EssentialsPE " . TextFormat::YELLOW . "v" . TextFormat::GREEN . $sender->getServer()->getPluginManager()->getPlugin("EssentialsPE")->getDescription()->getVersion());
                        break;
                    default:
                        $this->sendUsage($sender, $alias);
                        return false;
                        break;
                }
                break;
            default:
                $this->sendUsage($sender, $alias);
                return false;
                break;
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Extinguish extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "extinguish", "Extinguish a player", "[player]", true, ["ext"]);
        $this->setPermission("essentials.extinguish.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.extinguish.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $player->extinguish();
        $sender->sendMessage(TextFormat::AQUA . ($player === $sender ? "You were" : $player->getDisplayName() . "has been") . TextFormat::AQUA . " extinguished");
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Fly extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "fly", "Fly in Survival or Adventure mode", "[player]");
        $this->setPermission("essentials.fly.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.fly.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $this->getAPI()->switchCanFly($player);
        $player->sendMessage(TextFormat::YELLOW . "Flying mode " . ($this->getAPI()->canFly($player) ? "enabled" : "disabled") . "!");
        if($player !== $sender){
            $sender->sendMessage(TextFormat::YELLOW . "Flying mode " . ($this->getAPI()->canFly($player) ? "enabled" : "disabled") . " for " . $player->getDisplayName());
        }
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class GetPos extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "getpos", "Get your/other's position", "[player]", true, ["coords", "position", "whereami", "getlocation", "getloc"]);
        $this->setPermission("essentials.getpos.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.getpos.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $sender->sendMessage(TextFormat::GREEN . ($player === $sender ? "You're" : $player->getDisplayName() . TextFormat::GRAY . "is") . "in world: " . TextFormat::AQUA . $player->getLevel()->getName() . "\n" . TextFormat::GREEN . "Coordinates: " . TextFormat::YELLOW . "X: " . TextFormat::AQUA . $player->getFloorX() . TextFormat::GREEN . ", " . TextFormat::YELLOW . "Y: " . TextFormat::AQUA . $player->getFloorY() . TextFormat::GREEN . ", " . TextFormat::YELLOW . "Z: " . TextFormat::AQUA . $player->getFloorZ());
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class God extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "god", "Prevent you from taking any damage", "[player]", true, ["godmode", "tgm"]);
        $this->setPermission("essentials.god.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.god.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $this->getAPI()->switchGodMode($player);
        $player->sendMessage(TextFormat::AQUA . "God mode " . ($m = $this->getAPI()->isGod($player) ? "enabled" : "disabled"));
        if($player !== $sender){
            $sender->sendMessage(TextFormat::AQUA . "God mode $m");
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\event\entity\EntityRegainHealthEvent;
use pocketmine\level\particle\HeartParticle;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Heal extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "heal", "Heal yourself or other player", "[player]");
        $this->setPermission("essentials.heal.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0]) && !($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        $player->heal($player->getMaxHealth(), new EntityRegainHealthEvent($player, $player->getMaxHealth() - $player->getHealth(), EntityRegainHealthEvent::CAUSE_CUSTOM));
        $player->getLevel()->addParticle(new HeartParticle($player->add(0, 2), 4));
        $player->sendMessage(TextFormat::GREEN . "You have been healed!");
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . $player->getDisplayName() . " has been healed!");
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ItemCommand extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "item", "Gives yourself an item", "<item[:damage]> [amount]", false, ["i"]);
        $this->setPermission("essentials.item");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || (count($args) < 1 || count($args) > 2)){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(($gm = $sender->getGamemode()) === Player::CREATIVE || $gm === Player::SPECTATOR){
            $sender->sendMessage(TextFormat::RED . "[Error] You're in " . $this->getAPI()->getServer()->getGamemodeString($gm) . " mode");
            return false;
        }

        //Getting the item...
        $item = $this->getAPI()->getItem($item_name = array_shift($args));

        if($item->getId() === Item::AIR){
            $sender->sendMessage(TextFormat::RED . "Unknown item \"" . $item_name . "\"");
            return false;
        }elseif(!$sender->hasPermission("essentials.itemspawn.item-all") && !$sender->hasPermission("essentials.itemspawn.item-" . $item->getName() && !$sender->hasPermission("essentials.itemspawn.item-" . $item->getId()))){
            $sender->sendMessage(TextFormat::RED . "You can't spawn this item");
            return false;
        }

        //Setting the amount...
        $amount = array_shift($args);
        $item->setCount(isset($amount) && is_numeric($amount) ? $amount : ($sender->hasPermission("essentials.oversizedstacks") ? $this->getPlugin()->getConfig()->get("oversized-stacks") : $item->getMaxStackSize()));

        //Getting other values... TODO
        /*foreach($args as $a){
            //Example
            if(stripos(strtolower($a), "color") !== false){
                $v = explode(":", $a);
                $color = $v[1];
            }
        }*/

        //Giving the item...
        $sender->getInventory()->setItem($sender->getInventory()->firstEmpty(), $item);
        $sender->sendMessage(TextFormat::YELLOW . "Giving " . TextFormat::RED . $item->getCount() . TextFormat::YELLOW . " of " . TextFormat::RED . ($item->getName() === "Unknown" ? $item_name : $item->getName()));
        return false;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ItemDB extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "itemdb", "Display the information attached to the item you hold", "[name|id|meta]", false, ["itemno", "durability", "dura"]);
        $this->setPermission("essentials.itemdb");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $item = $sender->getInventory()->getItemInHand();
        $m = TextFormat::AQUA . "This item " . ($this->getAPI()->isRepairable($item) ? "has " . TextFormat::RED . $item->getDamage() . TextFormat::AQUA . " points of damage" : "metadata is " . TextFormat::RED . $item->getDamage());
        if(isset($args[0])){
            switch(strtolower($args[0])){
                case "name":
                    $m = TextFormat::AQUA . "This item is named: " . TextFormat::RED . $item->getName();
                    break;
                case "id":
                    $m = TextFormat::AQUA . "This item ID is: " . TextFormat::RED . $item->getId();
                    break;
                case "durability":
                case "dura":
                case "metadata":
                case "meta":
                    $m = TextFormat::AQUA . "This item " . ($this->getAPI()->isRepairable($item) ? "has " . TextFormat::RED . $item->getDamage() . TextFormat::AQUA . " points of damage" : "metadata is " . TextFormat::RED . $item->getDamage());
                    break;
            }
        }
        $sender->sendMessage($m);
        return true;
    }
} <?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Jump extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "jump", "Teleport you to the block you're looking at", null, false, ["j", "jumpto"]);
        $this->setPermission("essentials.jump");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $block = $sender->getTargetBlock(100, BaseAPI::NON_SOLID_BLOCKS);
        if($block === null){
            $sender->sendMessage(TextFormat::RED . "There isn't a reachable block");
            return false;
        }
        if(!$sender->getLevel()->getBlock($block->add(0, 2))->isSolid()){
            $sender->teleport($block->add(0, 1));
            return true;
        }
        switch($side = $sender->getDirection()){
            case 0:
            case 1:
                $side += 3;
                break;
            case 3:
                $side += 2;
                break;
            default:
                break;
        }
        if(!$block->getSide($side)->isSolid()){
            $sender->teleport($block);
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class KickAll extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "kickall", "Kick all the players", "<reason>");
        $this->setPermission("essentials.kickall");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(($count = count($this->getAPI()->getServer()->getOnlinePlayers())) < 1 || ($sender instanceof Player && $count < 2)){
            $sender->sendMessage(TextFormat::RED . "[Error] There are no more players in the server");
            return false;
        }
        if(count($args) < 1){
            $reason = "Unknown";
        }else{
            $reason = implode(" ", $args);
        }
        foreach($this->getAPI()->getServer()->getOnlinePlayers() as $p){
            if($p != $sender){
                $p->kick($reason, false);
            }
        }
        $sender->sendMessage(TextFormat::AQUA . "Kicked all the players!");
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Kit extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "kit", "Get a pre-defined kit!", "[name] [player]", "[<name> <player>]", ["kits"]);
        $this->setPermission("essentials.kit.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) > 2){
            $this->sendUsage($sender, $alias);
            return false;
        }elseif(count($args) === 0){
            if(($list = $this->getAPI()->kitList(false)) === false){
                $sender->sendMessage(TextFormat::AQUA . "There are currently no Kits available");
                return false;
            }
            $sender->sendMessage(TextFormat::AQUA . "Available kits:\n" . $list);
            return true;
        }elseif(!isset($args[1]) && !$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }elseif(!($kit = $this->getAPI()->getKit($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Kit doesn't exist");
            return false;
        }
        switch(count($args)){
            case 1:
                if(!$sender instanceof Player){
                    $this->sendUsage($sender, $alias);
                    return false;
                }
                if(!$sender->hasPermission("essentials.kits.*") && !$sender->hasPermission("essentials.kits." . strtolower($args[0]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] You can't obtain this kit");
                    return false;
                }
                $kit->giveToPlayer($sender);
                $sender->sendMessage(TextFormat::GREEN . "Getting kit " . TextFormat::AQUA . $kit->getName() . "...");
                break;
            case 2:
                if(!$sender->hasPermission("essentials.kit.other")){
                    $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                    return false;
                }
                if(!$sender->hasPermission("essentials.kits.*") && !$sender->hasPermission("essentials.kits." . strtolower($args[0]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] You can't obtain this kit");
                    return false;
                }
                if(!($player = $this->getAPI()->getPlayer($args[1]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                    return false;
                }
                $kit->giveToPlayer($player);
                $player->sendMessage(TextFormat::GREEN . "Getting kit " . TextFormat::AQUA . $kit->getName() . "...");
                $sender->sendMessage(TextFormat::GREEN . "Giving " . TextFormat::YELLOW . $player->getDisplayName() . TextFormat::GREEN . " kit " . TextFormat::AQUA . $kit->getName() . TextFormat::GREEN . "...");
                break;
            default:
                $this->sendUsage($sender, $alias);
                return false;
                break;
        }
        $player = $sender;
        if(isset($args[1])){
            if(!$sender->hasPermission("essentials.kit.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[1]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if(!$sender->hasPermission("essentials.kits.*") && !$sender->hasPermission("essentials.kits." . strtolower($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't obtain this kit");
            return false;
        }
        $player->sendMessage(TextFormat::GREEN . "Getting kit " . TextFormat::AQUA . $kit->getName() . "...");
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . "Giving " . TextFormat::YELLOW . $player->getDisplayName() . TextFormat::GREEN . " kit " . TextFormat::AQUA . $kit->getName() . TextFormat::GREEN . "...");
        }
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Lightning extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "lightning", "Strike lightning", "[player [damage]]", "<player> [damage]", ["strike", "smite", "thor", "shock"]);
        $this->setPermission("essentials.lightning.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 2){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0]) && !($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        $pos = isset($args[0]) ? $player : $player->getTargetBlock(100);
        $damage = isset($args[1]) ? $args[1] : 0;
        $this->getAPI()->strikeLightning($pos, $damage);
        $sender->sendMessage(TextFormat::YELLOW . "Lightning launched!");
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class More extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "more", "Get a stack of the item you're holding", null, false);
        $this->setPermission("essentials.more");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(($gm = $sender->getGamemode()) === Player::CREATIVE || $gm === Player::SPECTATOR){
            $sender->sendMessage(TextFormat::RED . "[Error] You're in " . $this->getAPI()->getServer()->getGamemodeString($gm) . " mode");
            return false;
        }
        $item = $sender->getInventory()->getItemInHand();
        if($item->getId() === Item::AIR){
            $sender->sendMessage(TextFormat::RED . "You can't get a stack of AIR");
            return false;
        }
        $item->setCount($sender->hasPermission("essentials.oversizedstacks") ? $this->getPlugin()->getConfig()->get("oversized-stacks") : $item->getMaxStackSize());
        $sender->sendMessage(TextFormat::AQUA . "Filled up the item stack to " . $item->getCount());
        return true;
    }
}
<?php

namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class Mute extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "mute", "Prevent a player from chatting", "<player> [time...]", true, ["silence"]);
        $this->setPermission("essentials.mute.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) < 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer(array_shift($args)))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found.");
            return false;
        }
        if($player->hasPermission("essentials.mute.exempt") && !$this->getAPI()->isMuted($player)){
            $sender->sendMessage(TextFormat::RED . $player->getDisplayName() . " can't be muted");
            return false;
        }
        /** @var \DateTime $date */
        $date = null;
        if(!is_bool($info = $this->getAPI()->stringToTimestamp(implode(" ", $args)))){
            $date = $info[0];
        }
        $this->getAPI()->switchMute($player, $date, true);
        $sender->sendMessage(TextFormat::YELLOW . $player->getDisplayName() . " has been " . ($this->getAPI()->isMuted($player) ? "muted " . ($date !== null ? "until: " . TextFormat::AQUA . $date->format("l, F j, Y") . TextFormat::RED . " at " . TextFormat::AQUA . $date->format("h:ia") : TextFormat::AQUA . "Forever" . TextFormat::YELLOW . "!") : "unmuted!"));
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Near extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "near", "List the players near to you", "[player]", true, ["nearby"]);
        $this->setPermission("essentials.near.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) || !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.near.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $who = $player === $sender ? "you" : $player->getDisplayName();
        if(count($near = $this->getAPI()->getNearPlayers($player)) < 1){
            $m = TextFormat::GRAY . "** There are no players near to " . $who . TextFormat::GRAY . "! **";
        }else{
            $m = TextFormat::YELLOW . "** There " . (count($near) > 1 ? "are " : "is ") . TextFormat::AQUA . count($near) . TextFormat::YELLOW . "player" . (count($near) > 1 ? "s " : " ") . "near to " . $who . TextFormat::YELLOW . ":";
            foreach($near as $p){
                $m .= TextFormat::YELLOW . "\n* " . TextFormat::RESET . $p->getDisplayName();
            }
        }
        $sender->sendMessage($m);
        return true;
    }
} <?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Nick extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "nick", "Change your in-game name", "<new nick|off> [player]", true, ["nickname"]);
        $this->setPermission("essentials.nick.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[1]) && !$sender instanceof Player) || (count($args) < 1 || count($args) > 2)){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $nick = ($n = strtolower($alias[0])) === "off" || $n === "remove" || (bool) $n === false ? false : $args[0];
        $player = $sender;
        if(isset($args[1])){
            if(!$sender->hasPermission("essentials.nick.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[1]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if(!$nick){
            $this->getAPI()->removeNick($player);
        }else{
            if(!$this->getAPI()->setNick($player, $nick)){
                $sender->sendMessage(TextFormat::RED . "[Error] You don't have permissions to give 'colored' nicknames");
            }
        }
        $player->sendMessage(TextFormat::GREEN . "Your nick " . ($m = !$nick ? "has been removed" : "is now " . TextFormat::RESET . $nick));
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . $player->getName() . (substr($player->getName(), -1, 1) === "s" ? "'" : "'s") . " nick " . $m);
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Nuke extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "nuke", "Lay down a carpet of TNT", "[player]");
        $this->setPermission("essentials.nuke.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.nuke.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $this->getAPI()->nuke($player);
        return true;
    }
} <?php
namespace EssentialsPE\Commands;


use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;

class Ping extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "ping", "Pong!");
        $this->setPermission("essentials.ping");
    }
    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        $sender->sendMessage("Pong!");
        return true;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\level\particle\HappyVillagerParticle;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Feed extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "feed", "Feed yourself or other players", "[player]");
        $this->setPermission("essentials.feed.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0]) && !($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        $player->setFood(20);
        $player->getLevel()->addParticle(new HappyVillagerParticle($player->add(0, 2), 4));
        $player->sendMessage(TextFormat::GREEN . "You have been fed!");
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . $player->getDisplayName() . " has been fed!");
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class PTime extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "ptime", "Changes the time of a player", "<time> [player]", true, ["playertime"]);
        $this->setPermission("essentials.ptime.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || (count($args) < 1 || count($args) > 2)){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $static = ($alias[0][0] === "@");
        $time = strtolower((!$static ? $args[0] : substr($args[0], 1)));
        if(!is_int($time)){
            switch($time){
                case "dawn":
                case "sunrise":
                    $time = Level::TIME_SUNRISE;
                    break;
                case "day":
                    $time = Level::TIME_DAY;
                    break;
                case "noon":
                    $time = 6000;
                    break;
                case "evening":
                case "sunset":
                    $time = Level::TIME_SUNSET;
                    break;
                case "night":
                    $time = Level::TIME_NIGHT;
                    break;
            }
        }
        $player = $sender;
        if(isset($args[1])){
            if(!$sender->hasPermission("essentials.ptime.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[1]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if(!$this->getAPI()->setPlayerTime($player, (int) $time)){
            $sender->sendMessage(TextFormat::RED . "Something went wrong while setting the time");
            return false;
        }
        $sender->sendMessage(TextFormat::GREEN . "Setting player time...");
        return false;
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class PvP extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "pvp", "Toggle PvP on/off", "<on|true|enable|off|false|disable>", false);
        $this->setPermission("essentials.pvp");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) != 1 || !((($s = strtolower($args[0])) === "on" || (bool) $s || $s === "enable") || ($s === "off" || !((bool) $s)) || $s === "disable")){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $this->getAPI()->setPvP($sender, $s);
        $sender->sendMessage(TextFormat::GREEN . "PvP mode " . ($s ? "enabled" : "disabled"));
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class RealName extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "realname", "Check the real name of a player", "<player>");
        $this->setPermission("essentials.realname");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) != 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        $sender->sendMessage(TextFormat::YELLOW .  $player->getDisplayName() . (substr($player->getName(), -1, 1) === "s" ? "'" : "'s") . " realname is: " . TextFormat::RED . $player->getName());
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Repair extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "repair", "Repair items in your inventory", "[all|hand]", false, ["fix"]);
        $this->setPermission("essentials.repair.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(isset($args[0])) {
            $a = strtolower($args[0]);
        }
        if(!($a === "hand" || $a === "all")){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if($a === "all"){
            if(!$sender->hasPermission("essentials.repair.all")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }
            foreach($sender->getInventory()->getContents() as $item){
                if($this->getAPI()->isRepairable($item)){
                    $item->setDamage(0);
                }
            }
            $m = TextFormat::GREEN . "All the tools in your inventory were repaired!";
            if($sender->hasPermission("essentials.repair.armor")){
                foreach($sender->getInventory()->getArmorContents() as $item){
                    if($this->getAPI()->isRepairable($item)){
                        $item->setDamage(0);
                    }
                }
                $m .= TextFormat::AQUA . " (Including the equipped Armor)";
            }
        }else{
            if(!$this->getAPI()->isRepairable($sender->getInventory()->getItemInHand())){
                $sender->sendMessage(TextFormat::RED . "[Error] This item can't be repaired!");
                return false;
            }
            $sender->getInventory()->getItemInHand()->setDamage(0);
            $m = TextFormat::GREEN . "Item successfully repaired!";
        }
        $sender->sendMessage($m);
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Seen extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "seen", "See player's last played time", "<player>");
        $this->setPermission("essentials.seen");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(($player = $this->getAPI()->getOfflinePlayer($args[0])) instanceof Player){
            $sender->sendMessage(TextFormat::GREEN . $player->getDisplayName() . " is online!");
            return true;
        }
        if(!is_numeric($player->getLastPlayed())){
            $sender->sendMessage(TextFormat::RED .  $args[0] . " has never played on this server.");
            return false;
        }
        /**
         * a = am/pm
         * i = Minutes
         * h = Hour (12 hours format with leading zeros)
         * l = Day name
         * j = Day number (1 - 30/31)
         * F = Month name
         * Y = Year in 4 digits (1999)
         */
        $sender->sendMessage(TextFormat::AQUA .  $player->getName() ." was last seen on " . TextFormat::RED . date("l, F j, Y", ($t = $player->getLastPlayed() / 1000)) . TextFormat::AQUA . " at " . TextFormat::RED . date("h:ia", $t));
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SetSpawn extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "setspawn", "Change your server main spawn point", null, false);
        $this->setPermission("essentials.setspawn");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) != 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $sender->getLevel()->setSpawnLocation($sender);
        $sender->getServer()->setDefaultLevel($sender->getLevel());
        $sender->sendMessage(TextFormat::YELLOW . "Server's spawn point changed!");
        $this->getAPI()->getServer()->getLogger()->info(TextFormat::YELLOW . "Server's spawn point set to " . TextFormat::AQUA . $sender->getLevel()->getName() . TextFormat::YELLOW . " by " . TextFormat::GREEN . $sender->getName());
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\level\Location;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Spawn extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "spawn", "Teleport to server's main spawn", "[player]");
        $this->setPermission("essentials.spawn.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.spawn.other")){
                $sender->sendMessage(TextFormat::RED . "[Error] You can't teleport other players to spawn");
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $player->teleport(Location::fromObject($this->getAPI()->getServer()->getDefaultLevel()->getSpawnLocation(), $this->getAPI()->getServer()->getDefaultLevel()));
        $player->sendMessage(TextFormat::GREEN . "Teleporting...");
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\event\player\PlayerChatEvent;
use pocketmine\utils\TextFormat;

class Sudo extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "sudo", "Run a command as another player", "<player> <command line|c:<chat message>");
        $this->setPermission("essentials.sudo.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) < 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer(array_shift($args)))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }elseif($player->hasPermission("essentials.sudo.exempt")){
            $sender->sendMessage(TextFormat::RED . "[Error] " . $player->getName() . " cannot be sudo'ed");
            return false;
        }

        $v = implode(" ", $args);
        if(substr($v, 0, 2) === "c:"){
            $sender->sendMessage(TextFormat::GREEN . "Sending message as " .  $player->getDisplayName());
            $this->getAPI()->getServer()->getPluginManager()->callEvent($ev = new PlayerChatEvent($player, substr($v, 2)));
            if(!$ev->isCancelled()){
                $this->getAPI()->getServer()->broadcastMessage(\sprintf($ev->getFormat(), $ev->getPlayer()->getDisplayName(), $ev->getMessage()), $ev->getRecipients());
            }
        }else{
            $sender->sendMessage(TextFormat::AQUA . "Command ran as " .  $player->getDisplayName());
            $this->getAPI()->getServer()->dispatchCommand($player, $v);
        }
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\Player;

class Suicide extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "suicide", "Kill yourself", null, false);
        $this->setPermission("essentials.suicide");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $sender->getServer()->getPluginManager()->callEvent($ev = new EntityDamageEvent($sender, EntityDamageEvent::CAUSE_SUICIDE, ($sender->getHealth())));
        if($ev->isCancelled()){
            return true;
        }
        $sender->setLastDamageCause($ev);
        $sender->setHealth(0);
        $sender->sendMessage("Ouch. That looks like it hurt.");
        return true;
    }
} <?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TempBan extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tempban", "Temporarily bans the specified player", "<player> <time...> [reason ...]");
        $this->setPermission("essentials.tempban");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) < 2){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $name = array_shift($args);
        if(!($info = $this->getAPI()->stringToTimestamp(implode(" ", $args)))){
            $sender->sendMessage(TextFormat::RED . "[Error] Please specify a valid time");
            return false;
        }
        /** @var \DateTime $date */
        $date = $info[0];
        $reason = $info[1];
        if(($player = $this->getAPI()->getPlayer($name)) instanceof Player){
            if($player->hasPermission("essentials.ban.exempt")){
                $sender->sendMessage(TextFormat::RED . "[Error] " . $player->getDisplayName() . " can't be banned");
                return false;
            }else{
                $player->kick(TextFormat::RED . "Banned until " . TextFormat::AQUA . $date->format("l, F j, Y") . TextFormat::RED . " at " . TextFormat::AQUA . $date->format("h:ia") . (trim($reason) !== "" ? TextFormat::YELLOW . "\nReason: " . TextFormat::RESET . $reason : ""), false);
            }
        }
        $sender->getServer()->getNameBans()->addBan(($player instanceof Player ? $player->getName() : $name), (trim($reason) !== "" ? $reason : null), $date, "essentialspe");
        $this->broadcastCommandMessage($sender, "Banned player " . ($player instanceof Player ? $player->getName() : $name) . " until " . $date->format("l, F j, Y") . " at " . $date->format("h:ia") . (trim($reason) !== "" ? TextFormat::YELLOW . " Reason: " . TextFormat::RESET . $reason : ""));
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;
use pocketmine\math\Vector3;

class Top extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "top", "Teleport to the highest block above you", null, false);
        $this->setPermission("essentials.top");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $sender->sendMessage(TextFormat::YELLOW . "Teleporting...");
        $sender->teleport(new Vector3($sender->getX(), $sender->getLevel()->getHighestBlockAt($sender->getX(), $sender->getZ()) + 1, $sender->getZ())); 
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Unlimited extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "unlimited", "Allow you to place unlimited blocks", "[player]", true, ["ul", "unl"]);
        $this->setPermission("essentials.unlimited.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.unlimited.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if(($gm = $player->getGamemode()) === Player::CREATIVE || $gm === Player::SPECTATOR){
            $sender->sendMessage(TextFormat::RED . "[Error] " . ($player === $sender ? "you are" : $player->getDisplayName() . " is") . " in " . $this->getAPI()->getServer()->getGamemodeString($gm) . " mode");
            return false;
        }
        $this->getAPI()->switchUnlimited($player);
        $player->sendMessage(TextFormat::GREEN . "Unlimited placing of blocks " . ($s = $this->getAPI()->isUnlimitedEnabled($player) ? "enabled" : "disabled"));
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . "Unlimited placing of blocks $s");
        }
        return true;
    }
} <?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Vanish extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "vanish", "Hide from other players", "[player]", true, ["v"]);
        $this->setPermission("essentials.vanish.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.vanish.other")){
                $sender->sendMessage($this->getPermissionMessage());
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[0]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $this->getAPI()->switchVanish($player);
        $player->sendMessage(TextFormat::GRAY . "You're now " . ($s = $this->getAPI()->isVanished($player) ? "vanished" : "visible"));
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GRAY .  $player->getDisplayName() . " is now $s");
        }
        return true;
    }
}
<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class World extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "world", "Teleport between worlds", "<world name>", false);
        $this->setPermission("essentials.world");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!$sender->hasPermission("essentials.worlds.*") && !$sender->hasPermission("essentials.worlds." . strtolower($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't teleport to this world.");
            return false;
        }
        if(!$sender->getServer()->isLevelGenerated($args[0])){
            $sender->sendMessage(TextFormat::RED . "[Error] World doesn't exist");
            return false;
        }elseif(!$sender->getServer()->isLevelLoaded($args[0])){
            $sender->sendMessage(TextFormat::YELLOW . "Level is not loaded yet. Loading...");
            if(!$sender->getServer()->loadLevel($args[0])){
                $sender->sendMessage(TextFormat::RED . "[Error] The level couldn't be loaded");
                return false;
            }
        }
        $sender->teleport($this->getAPI()->getServer()->getLevelByName($args[0])->getSpawnLocation(), 0, 0);
        $sender->sendMessage(TextFormat::YELLOW . "Teleporting...");
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands\Override;

use EssentialsPE\BaseFiles\BaseAPI;
use pocketmine\command\CommandSender;
use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\RemoteConsoleCommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Msg extends BaseOverrideCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tell", "Send private messages to other players", "<player> <message ...>", true, ["msg", "m", "t", "whisper"]);
        $this->setPermission("essentials.msg");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) < 2){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $t = array_shift($args);
        if(strtolower($t) !== "console" && strtolower($t) !== "rcon"){
            $t = $this->getAPI()->getPlayer($t);
            if(!$t){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $sender->sendMessage(TextFormat::YELLOW . "[me -> " . ($t instanceof Player ? $t->getDisplayName() : $t) . "]" . TextFormat::RESET . " " . implode(" ", $args));
        $m = TextFormat::YELLOW . "[" . ($sender instanceof Player ? $sender->getDisplayName() : $sender->getName()) . " -> me]" . TextFormat::RESET . " " . implode(" ", $args);
        if($t instanceof Player){
            $t->sendMessage($m);
        }else{
            $this->getPlugin()->getLogger()->info($m);
        }
        $this->getAPI()->setQuickReply(($t instanceof Player ? $t : ($t === "console" ? new ConsoleCommandSender() : new RemoteConsoleCommandSender())), $sender);
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Override;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;

abstract class BaseOverrideCommand extends BaseCommand{
    /**
     * @param BaseAPI $api
     * @param string $name
     * @param string $description
     * @param null|string $usageMessage
     * @param bool|null|string $consoleUsageMessage
     * @param array $aliases
     */
    public function __construct(BaseAPI $api, $name, $description = "", $usageMessage = null, $consoleUsageMessage = true, array $aliases = []){
        parent::__construct($api, $name, $description, $usageMessage, $consoleUsageMessage, $aliases);
        // Special part :D
        $commandMap = $api->getServer()->getCommandMap();
        $command = $commandMap->getCommand($name);
        $command->setLabel($name . "_disabled");
        $command->unregister($commandMap);
    }
}<?php
namespace EssentialsPE\Commands;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\RemoteConsoleCommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Reply extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "reply", "Quickly reply to the last person that messaged you", "<message ...>", true, ["r"]);
        $this->setPermission("essentials.reply");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) < 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($t = $this->getAPI()->getQuickReply($sender))){
            $sender->sendMessage(TextFormat::RED . "[Error] No target available for QuickReply");
            return false;
        }
        if(strtolower($t) !== "console" && strtolower($t) !== "rcon"){
            if(!($t = $this->getAPI()->getPlayer($t))){
                $sender->sendMessage(TextFormat::RED . "[Error] No player available for QuickReply");
                $this->getAPI()->removeQuickReply($sender);
                return false;
            }
        }
        $sender->sendMessage(TextFormat::YELLOW . "[me -> " . ($t instanceof Player ? $t->getDisplayName() : $t) . "]" . TextFormat::RESET . " " . implode(" ", $args));
        $m = TextFormat::YELLOW . "[" . ($sender instanceof Player ? $sender->getDisplayName() : $sender->getName()) . " -> me]" . TextFormat::RESET . " " . implode(" ", $args);
        if($t instanceof Player){
            $t->sendMessage($m);
        }else{
            $this->getPlugin()->getLogger()->info($m);
        }
        $this->getAPI()->setQuickReply(($t instanceof Player ? $t : ($t === "console" ? new ConsoleCommandSender() : new RemoteConsoleCommandSender())), $sender);
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Override;

use EssentialsPE\BaseFiles\BaseAPI;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Gamemode extends BaseOverrideCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "gamemode", "Change player gamemode", "<mode> [player]", true, ["gm", "gma", "gmc", "gms", "gmt", "adventure", "creative", "survival", "spectator", "viewer"]);
        $this->setPermission("essentials.gamemode");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(strtolower($alias) !== "gamemode" && strtolower($alias) !== "gm"){
            if(isset($args[0])){
                $args[1] = $args[0];
                unset($args[0]);
            }
            switch(strtolower($alias)){
                case "survival":
                case "gms":
                    $args[0] = Player::SURVIVAL;
                    break;
                case "creative":
                case "gmc":
                    $args[0] = Player::CREATIVE;
                    break;
                case "adventure":
                case "gma":
                    $args[0] = Player::ADVENTURE;
                    break;
                case "spectator":
                case "viewer":
                case "gmt":
                    $args[0] = Player::SPECTATOR;
                    break;
                default:
                    return false;
                    break;
            }
        }
        if(count($args) < 1 || (!($player = $sender) instanceof Player && !isset($args[1]))){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(isset($args[1]) && !($player = $this->getAPI()->getPlayer($args[1]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }

        /**
         * The following switch is applied when the user execute:
         * /gamemode <MODE>
         */
        if(is_numeric($args[0])){
            switch($args[0]){
                case Player::SURVIVAL:
                case Player::CREATIVE:
                case Player::ADVENTURE:
                case Player::SPECTATOR:
                    $gm = $args[0];
                    break;
                default:
                    $sender->sendMessage(TextFormat::RED . "[Error] Please specify a valid gamemode");
                    return false;
                    break;
            }
        }else{
            switch(strtolower($args[0])){
                case "survival":
                case "s":
                    $gm = Player::SURVIVAL;
                    break;
                case "creative":
                case "c":
                    $gm = Player::CREATIVE;
                    break;
                case "adventure":
                case "a":
                    $gm = Player::ADVENTURE;
                    break;
                case "spectator":
                case "viewer":
                case "view":
                case "v":
                case "t":
                    $gm = Player::SPECTATOR;
                    break;
                default:
                    $sender->sendMessage(TextFormat::RED . "[Error] Please specify a valid gamemode");
                    return false;
                    break;
            }
        }
        $gmstring = $this->getAPI()->getServer()->getGamemodeString($gm);
        if($player->getGamemode() === $gm){
            $sender->sendMessage(TextFormat::RED . "[Error] " . ($player === $sender ? "You're" : $player->getDisplayName() . " is") . " already in " . $gmstring);
            return false;
        }
        $player->setGamemode($gm);
        $player->sendMessage(TextFormat::YELLOW . "You're now in " . $gmstring);
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . $player->getDisplayName() . " is now in " . $gmstring);
        }
        return true;
    }

    public function sendUsage(CommandSender $sender, string $alias){
        $usage = $this->usageMessage;
        if(strtolower($alias) !== "gamemode" && strtolower($alias) !== "gm"){
            $usage = str_replace("<mode> ", "", $usage);
        }
        if(!$sender instanceof Player){
            $usage = str_replace("[player]", "<player>", $usage);
        }
        $sender->sendMessage(TextFormat::RED . "Usage: " . TextFormat::GRAY . "/$alias $usage");
    }
} 
<?php
namespace EssentialsPE\Commands\Override;

use EssentialsPE\BaseFiles\BaseAPI;
use pocketmine\command\CommandSender;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Kill extends BaseOverrideCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "kill", "Kill other people", "[player]");
        $this->setPermission("essentials.kill.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player && count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.kill.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }
            if(!($player = $this->getAPI()->getPlayer($args[0])) instanceof Player){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if($this->getAPI()->isGod($player)){
            $sender->sendMessage(TextFormat::RED . $args[0] . " can't be killed!");
            return false;
        }
        $sender->getServer()->getPluginManager()->callEvent($ev = new EntityDamageEvent($player, EntityDamageEvent::CAUSE_SUICIDE, ($player->getHealth())));
        if($ev->isCancelled()){
            return true;
        }

        $player->setLastDamageCause($ev);
        $player->setHealth(0);
        $player->sendMessage("Ouch. That looks like it hurt.");
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Balance extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "balance", "See how many money do you have", "[player]", true, ["bal", "money"]);
        $this->setPermission("essentials.balance.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0])){
            if(!$sender->hasPermission("essentials.balance.other")){
                $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                return false;
            }elseif(!$player = $this->getAPI()->getPlayer($args[0])){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        $sender->sendMessage(TextFormat::AQUA . ($player === $sender ? "Your current balance is " : $player->getDisplayName() . TextFormat::AQUA . " has ") . TextFormat::YELLOW . $this->getAPI()->getCurrencySymbol() . $this->getAPI()->getPlayerBalance($player));
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class Eco extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "eco", "Changes the balance of a player", "<give|take|set|reset> <player> [amount]", true, ["economy"]);
        $this->setPermission("essentials.eco.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        switch(count($args)){
            case 2:
            case 3:
                if(!($player = $this->getAPI()->getPlayer($args[1]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                    return false;
                }
                if((!isset($args[2]) && strtolower($args[0]) !== "reset") || (isset($args[2]) && !is_numeric($args[2]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Please specify a" . (isset($args[2]) ? " valid" : "n") . " amount");
                    return false;
                }
                $balance = (int) $args[2];
                switch(strtolower($args[0])){
                    case "give":
                        $sender->sendMessage(TextFormat::YELLOW . "Adding the balance...");
                        $this->getAPI()->addToPlayerBalance($player, $balance);
                        break;
                    case "take":
                        $sender->sendMessage(TextFormat::YELLOW . "Taking the balance...");
                        $this->getAPI()->addToPlayerBalance($player, -$balance);
                        break;
                    case "set":
                        $sender->sendMessage(TextFormat::YELLOW . "Setting the balance...");
                        $this->getAPI()->setPlayerBalance($player, $balance);
                        break;
                    case "reset":
                        $sender->sendMessage(TextFormat::YELLOW . "Resetting balance...");
                        $this->getAPI()->setPlayerBalance($player, $this->getAPI()->getDefaultBalance());
                        break;
                }
                break;
            default:
                $this->sendUsage($sender, $alias);
                break;
        }
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Pay extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "pay", "Pays a player from your balance", "<player> <amount>", false);
        $this->setPermission("essentials.pay");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 2){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        if(substr($args[1], 0, 1) === "-"){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't pay a negative value");
            return false;
        }
        $balance = $this->getAPI()->getPlayerBalance($sender);
        $newBalance = $balance - (int) $args[1];
        if($balance < $args[1] || $newBalance < $this->getAPI()->getMinBalance() || ($newBalance < 0 && !$player->hasPermission("essentials.eco.loan"))){
            $sender->sendMessage(TextFormat::RED . "[Error] You don't have enough money to pay");
            return false;
        }
        $sender->sendMessage(TextFormat::YELLOW . "Paying...");
        $this->getAPI()->setPlayerBalance($sender, $newBalance); //Take out from the payer balance.
        $this->getAPI()->addToPlayerBalance($player, (int) $args[1]); //Pay to the other player
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Sell extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "sell", "Sell the specified item", "<item|hand> [amount]", false);
        $this->setPermission("essentials.sell");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if($sender->getGamemode() === Player::CREATIVE || $sender->getGamemode() === Player::SPECTATOR){
            $sender->sendMessage(TextFormat::RED . "[Error] You're in " . $this->getAPI()->getServer()->getGamemodeString($sender->getGamemode()) . " mode");
            return false;
        }
        if(strtolower($args[0]) === "hand"){
            $item = $sender->getInventory()->getItemInHand();
            if($item->getId() === 0){
                $sender->sendMessage(TextFormat::RED . "[Error] You don't have anything in your hand");
                return false;
            }
        }else{
            if(!is_int($args[0])){
                $item = Item::fromString($args[0]);
            }else{
                $item = Item::get($args[0]);
            }
            if($item->getId() === 0){
                $sender->sendMessage(TextFormat::RED . "[Error] Unknown item");
                return false;
            }
        }
        if(!$sender->getInventory()->contains($item)){
            $sender->sendMessage(TextFormat::RED . "[Error] You don't have that item in your inventory");
            return false;
        }
        if(isset($args[1]) && !is_numeric($args[1])){
            $sender->sendMessage(TextFormat::RED . "[Error] Please specify a valid amount to sell");
            return false;
        }

        $amount = $this->getAPI()->sellPlayerItem($sender, $item, (isset($args[1]) ? $args[1] : null));
        if(!$amount){
            $sender->sendMessage(TextFormat::RED . "[Error] Worth not available for this item");
            return false;
        }elseif($amount === -1){
            $sender->sendMessage(TextFormat::RED . "[Error] You don't have that amount of items");
            return false;
        }

        if(is_array($amount)){
            $sender->sendMessage(TextFormat::RED . "Sold " . $amount[0] . " items! You got" . $this->getAPI()->getCurrencySymbol() . ($amount[1] * $amount[0]));
        }else{
            $sender->sendMessage(TextFormat::GREEN . "Item sold! You got " . $this->getAPI()->getCurrencySymbol() . $amount);
        }
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SetWorth extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "setworth", "Sets the worth of the item you're holding", "<worth>", false);
        $this->setPermission("essentials.setworth");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }elseif(!is_numeric($args[0]) || (int) $args[0] < 0){
            $sender->sendMessage(TextFormat::RED . "[Error] Please provide a valid worth");
            return false;
        }elseif(($id = $sender->getInventory()->getItemInHand()->getId()) === Item::AIR){
            $sender->sendMessage(TextFormat::RED . "[Error] Please provide a valid item");
            return false;
        }
        $sender->sendMessage(TextFormat::YELLOW . "Setting worth...");
        $this->getAPI()->setItemWorth($id, (int) $args[0]);
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Worth extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "worth", "Get the price of an item", "[item]", "<item>");
        $this->setPermission("essentials.worth");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!isset($args[0])){
            $id = $sender->getInventory()->getItemInHand()->getId();
        }else{
            $id = $this->getAPI()->getItem($args[0])->getId();
        }
        if(!($worth = $this->getAPI()->getItemWorth($id))){
            $sender->sendMessage(TextFormat::RED . "[Error] Worth not available for this item");
            return false;
        }
        $sender->sendMessage(TextFormat::AQUA . "Item's worth is " . $this->getAPI()->getCurrencySymbol() . $worth);
        return true;
    }
}<?php
namespace EssentialsPE\Commands\Economy;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class BalanceTop extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "balancetop", "See the top money", null, true, ["topbalance", "topmoney", "moneytop"]);
        $this->setPermission("essentials.balancetop.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) > 0){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $sender->sendMessage(TextFormat::GREEN . " --- Money top list ---");
        $this->getAPI()->sendBalanceTop($sender);
        return true;
    }
}
<?php
namespace EssentialsPE\Commands\Home;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class DelHome extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "delhome", "Remove a home", "<name>", false, ["remhome", "removehome"]);
        $this->setPermission("essentials.delhome");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!$this->getAPI()->homeExists($sender, $args[0])){
            $sender->sendMessage(TextFormat::RED . "[Error] Home doesn't exist");
            return false;
        }
        $this->getAPI()->removeHome($sender, $args[0]);
        $sender->sendMessage(TextFormat::GREEN . "Home successfully removed!");
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands\Home;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Home extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "home", "Teleport to your home", "<name>", false, ["homes"]);
        $this->setPermission("essentials.home.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(count($args) === 0){
            if(($list = $this->getAPI()->homesList($sender, false)) === false){
                $sender->sendMessage(TextFormat::AQUA . "You don't have any home yet");
                return false;
            }
            $sender->sendMessage(TextFormat::AQUA . "Available homes:\n" . $list);
            return true;
        }
        if(!($home = $this->getAPI()->getHome($sender, $args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Home doesn't exists or the world is not available");
            return false;
        }
        $sender->teleport($home);
        $sender->sendMessage(TextFormat::GREEN . "Teleporting to home " . TextFormat::AQUA . $home->getName() . TextFormat::GREEN . "...");
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Home;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SetHome extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "sethome", "Create or update a home position", "<name>", false, ["createhome"]);
        $this->setPermission("essentials.sethome");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(strtolower($args[0]) === "bed"){
            $sender->sendMessage(TextFormat::RED . "[Error] You can only set a \"bed\" home by sleeping in a bed");
            return false;
        }elseif(trim($args[0] === "")){
            $sender->sendMessage(TextFormat::RED . "[Error] Please provide a Home name");
            return false;
        }
        if(!$this->getAPI()->setHome($sender, strtolower($args[0]), $sender->getLocation(), $sender->getYaw(), $sender->getPitch())){
            $sender->sendMessage(TextFormat::RED . "Invalid home name given! Please be sure to only use alphanumerical characters and underscores");
            return false;
        }
        $sender->sendMessage(TextFormat::GREEN . "Home successfully " . ($this->getAPI()->homeExists($sender, $args[0]) ? "updated" : "created"));
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands\PowerTool;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class PowerTool extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "powertool", "Toggle PowerTool on the item you're holding", "<command|c:chat macro> <arguments...>", false, ["pt"]);
        $this->setPermission("essentials.powertool.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $item = $sender->getInventory()->getItemInHand();
        if($item->getId() === Item::AIR){
            $sender->sendMessage(TextFormat::RED . "You can't assign a command to an empty hand.");
            return false;
        }

        if(count($args) === 0){
            if(!$this->getAPI()->getPowerToolItemCommand($sender, $item) && !$this->getAPI()->getPowerToolItemCommands($sender, $item) && !$this->getAPI()->getPowerToolItemChatMacro($sender, $item)){
                $this->sendUsage($sender, $alias);
                return false;
            }
            if($this->getAPI()->getPowerToolItemCommand($sender, $item) !== false){
                $sender->sendMessage(TextFormat::GREEN . "Command removed from this item.");
            }elseif($this->getAPI()->getPowerToolItemCommands($sender, $item) !== false){
                $sender->sendMessage(TextFormat::GREEN . "Commands removed from this item.");
            }
            if($this->getAPI()->getPowerToolItemChatMacro($sender, $item) !== false){
                $sender->sendMessage(TextFormat::GREEN . "Chat macro removed from this item.");
            }
            $this->getAPI()->disablePowerToolItem($sender, $item);
        }else{
            if($args[0] === "pt" || $args[0] === "ptt" || $args[0] === "powertool" || $args[0] === "powertooltoggle"){
                $sender->sendMessage(TextFormat::RED . "This command can't be assigned");
                return false;
            }
            $command = implode(" ", $args);
            if(stripos($command, "c:") !== false){ //Create a chat macro
                $c = substr($command, 2);
                $this->getAPI()->setPowerToolItemChatMacro($sender, $item, $c);
                $sender->sendMessage(TextFormat::GREEN . "Chat macro successfully assigned to this item!");
            }elseif(stripos($command, "a:") !== false){
                if(!$sender->hasPermission("essentials.powertool.append")){
                    $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                    return false;
                }
                $commands = substr($command, 2);
                $commands = explode(";", $commands);
                $this->getAPI()->setPowerToolItemCommands($sender, $item, $commands);
                $sender->sendMessage(TextFormat::GREEN . "Commands successfully assigned to this item!");
            }elseif(stripos($command, "r:") !== false){
                if(!$sender->hasPermission("essentials.powertool.append")){
                    $sender->sendMessage(TextFormat::RED . $this->getPermissionMessage());
                    return false;
                }
                $command = substr($command, 2);
                $this->getAPI()->removePowerToolItemCommand($sender, $item, $command);
                $sender->sendMessage(TextFormat::YELLOW . "Command successfully removed from this item!");
            }elseif(count($args) === 1 && (($a = strtolower($args[0])) === "l" || $a === "d")){
                switch($a){
                    case "l":
                        $commands = false;
                        if($this->getAPI()->getPowerToolItemCommand($sender, $item) !== false){
                            $commands = $this->getAPI()->getPowerToolItemCommand($sender, $item);
                        }elseif($this->getAPI()->getPowerToolItemCommands($sender, $item) !== false){
                            $commands = $this->getAPI()->getPowerToolItemCommand($sender, $item);
                        }
                        $list = "=== Command ===";
                        if($commands === false){
                            $list .= "\n" . TextFormat::ITALIC . "**There aren't any commands for this item**";
                        }else{
                            if(!is_array($commands)){
                                $list .= "\n* /$commands";
                            }else{
                                foreach($commands as $c){
                                    $list .= "\n* /$c";
                                }
                            }
                        }
                        $chat_macro = $this->getAPI()->getPowerToolItemChatMacro($sender, $item);
                        $list .= "\n=== Chat Macro ===";
                        if($chat_macro === false){
                            $list .= "\n" . TextFormat::ITALIC . "**There aren't any chat macros for this item**";
                        }else{
                            $list .= "\n$chat_macro";
                        }
                        $list .= "\n=== End of the lists ===";
                        $sender->sendMessage($list);
                        return true;
                        break;
                    case "d":
                        if(!$this->getAPI()->getPowerToolItemCommand($sender, $item)){
                            $this->sendUsage($sender, $alias);
                            return false;
                        }
                        $this->getAPI()->disablePowerToolItem($sender, $item);
                        $sender->sendMessage(TextFormat::GREEN . "Command removed from this item.");
                        return true;
                        break;
                }
            }else{
                $this->getAPI()->setPowerToolItemCommand($sender, $item, $command);
                $sender->sendMessage(TextFormat::GREEN . "Command successfully assigned to this item!");
            }
        }
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands\Teleport;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPA extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tpa", "Asks the player if you can teleport to them", "<player>", false, ["call", "tpask"]);
        $this->setPermission("essentials.tpa");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        if($player->getName() === $sender->getName()){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't teleport to yourself");
            return false;
        }
        $this->getAPI()->requestTPTo($sender, $player);
        $player->sendMessage(TextFormat::AQUA . $sender->getName() . TextFormat::GREEN . " wants to teleport to you, please use:\n/tpaccept to accepts the request\n/tpdeny to decline the invitation");
        $sender->sendMessage(TextFormat::GREEN . "Teleport request sent to " . $player->getDisplayName() . "!");
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands\Teleport;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPAccept extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tpaccept", "Accept a teleport request", "[player]", false, ["tpyes"]);
        $this->setPermission("essentials.tpaccept");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($request = $this->getAPI()->hasARequest($sender))){
            $sender->sendMessage(TextFormat::RED . "[Error] You don't have any request yet");
            return false;
        }
        switch(count($args)){
            case 0:
                if(!($player = $this->getAPI()->getPlayer(($name = $this->getAPI()->getLatestRequest($sender))))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Request unavailable");
                    return false;
                }
                break;
            case 1:
                if(!($player = $this->getAPI()->getPlayer($args[0]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                    return false;
                }
                if(!($request = $this->getAPI()->hasARequestFrom($sender, $player))){
                    $sender->sendMessage(TextFormat::RED . "[Error] You don't have any requests from " . TextFormat::AQUA . $player->getDisplayName());
                    return false;
                }
                break;
            default:
                $this->sendUsage($sender, $alias);
                return false;
                break;
        }
        $player->sendMessage(TextFormat::AQUA . $sender->getDisplayName() . TextFormat::GREEN . " accepted your teleport request! Teleporting...");
        $sender->sendMessage(TextFormat::GREEN . "Teleporting...");
        $request = $this->getAPI()->hasARequestFrom($sender, $player);
        if($request === "tphere"){
            $sender->teleport($player);
        }else{
            $player->teleport($sender);
        }
        $this->getAPI()->removeTPRequest($player, $sender);
        return true;
    }
} 
<?php
namespace EssentialsPE\Commands\Teleport;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPAHere extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tpahere", "Request a player to teleport to your position", "<player>", false);
        $this->setPermission("essentials.tpahere");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        if($player->getName() === $sender->getName()){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't teleport to yourself");
            return false;
        }
        $this->getAPI()->requestTPHere($sender, $player);
        $player->sendMessage(TextFormat::AQUA . $sender->getName() . TextFormat::GREEN . " wants you to teleport to him, please use:\n/tpaccept to accepts the request\n/tpdeny to decline the invitation");
        $sender->sendMessage(TextFormat::GREEN . "Teleport request sent to " . $player->getDisplayName(). "!");
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Teleport;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPAll extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tpall", "Teleport all player to you or another player", "[player]");
        $this->setPermission("essentials.tpall");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if((!isset($args[0]) && !$sender instanceof Player) || count($args) > 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[0]) && !($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        foreach($this->getAPI()->getServer()->getOnlinePlayers() as $p){
            if($p !== $player){
                $p->teleport($player);
                $p->sendMessage(TextFormat::YELLOW . "Teleporting to " . $player->getDisplayName() . "...");
            }
        }
        $player->sendMessage(TextFormat::YELLOW . "Teleporting players to you...");
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Teleport;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPDeny extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tpdeny", "Decline a Teleport Request", "[player]", false, ["tpno"]);
        $this->setPermission("essentials.tpdeny");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($request = $this->getAPI()->hasARequest($sender))){
            $sender->sendMessage(TextFormat::RED . "[Error] You don't have any request yet");
            return false;
        }
        switch(count($args)){
            case 0:
                if(!($player = $this->getAPI()->getPlayer(($name = $this->getAPI()->getLatestRequest($sender))))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Request unavailable");
                    return false;
                }
                break;
            case 1:
                if(!($player = $this->getAPI()->getPlayer($args[0]))){
                    $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                    return false;
                }
                if(!($request = $this->getAPI()->hasARequestFrom($sender, $player))){
                    $sender->sendMessage(TextFormat::RED . "[Error] You don't have any requests from " . TextFormat::AQUA . $player->getName());
                    return false;
                }
                break;
            default:
                $this->sendUsage($sender, $alias);
                return false;
                break;
        }
        $player->sendMessage(TextFormat::AQUA . $sender->getDisplayName() . TextFormat::RED . " denied your teleport request");
        $sender->sendMessage(TextFormat::GREEN . "Denied " . TextFormat::AQUA . $player->getDisplayName() . (substr($player->getDisplayName(), -1, 1) === "s" ? "'" : "'s") . TextFormat::RED . " teleport request");
        $this->getAPI()->removeTPRequest($player, $sender);
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Teleport;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPHere extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "tphere", "Teleport a player to you", "<player>", false, ["s"]);
        $this->setPermission("essentials.tphere");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!($player = $this->getAPI()->getPlayer($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
            return false;
        }
        $player->teleport($sender);
        $player->sendMessage(TextFormat::YELLOW . "Teleporting to " . $sender->getDisplayName() . "...");
        $sender->sendMessage(TextFormat::YELLOW . "Teleporting " . $player->getDisplayName() . " to you...");
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Warp;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class DelWarp extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "delwarp", "Delete a warp", "<name>", true, ["remwarp", "removewarp", "closewarp"]);
        $this->setPermission("essentials.delwarp");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(!$this->getAPI()->warpExists($args[0])){
            $sender->sendMessage(TextFormat::RED . "[Error] Warp doesn't exists");
            return false;
        }
        if(!$sender->hasPermission("essentials.warp.override.*") && !$sender->hasPermission("essentials.warp.override.$args[0]")){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't delete this warp");
            return false;
        }
        $this->getAPI()->removeWarp($args[0]);
        $sender->sendMessage(TextFormat::GREEN . "Warp successfully removed!");
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Warp;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Setwarp extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "setwarp", "Create a warp (or update it)", "<name>", false, ["openwarp", "createwarp"]);
        $this->setPermission("essentials.setwarp");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(!$sender instanceof Player || count($args) !== 1){
            $this->sendUsage($sender, $alias);
            return false;
        }
        if(($existed = $this->getAPI()->warpExists($args[0])) && !$sender->hasPermission("essentials.warp.override.*") && !$sender->hasPermission("essentials.warp.override.$args[0]")){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't modify this warp position");
            return false;
        }
        if(!$this->getAPI()->setWarp($args[0], $sender->getPosition(), $sender->getYaw(), $sender->getPitch())){
            $sender->sendMessage(TextFormat::RED . "Invalid warp name given! Please be sure to only use alphanumerical characters and underscores");
            return false;
        }
        $sender->sendMessage(TextFormat::GREEN . "Warp successfully " . ($existed ? "updated!" : "created!"));
        return true;
    }
} <?php
namespace EssentialsPE\Commands\Warp;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCommand;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Warp extends BaseCommand{
    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api, "warp", "Teleport to a warp", "[[name] [player]]", true, ["warps"]);
        $this->setPermission("essentials.warp.use");
    }

    /**
     * @param CommandSender $sender
     * @param string $alias
     * @param array $args
     * @return bool
     */
    public function execute(CommandSender $sender, $alias, array $args): bool{
        if(!$this->testPermission($sender)){
            return false;
        }
        if(count($args) === 0){
            if(($list = $this->getAPI()->warpList(false)) === false){
                $sender->sendMessage(TextFormat::AQUA . "There are no Warps currently available");
                return false;
            }
            $sender->sendMessage(TextFormat::AQUA . "Available warps:\n" . $list);
            return true;
        }
        if(!($warp = $this->getAPI()->getWarp($args[0]))){
            $sender->sendMessage(TextFormat::RED . "[Error] Warp doesn't exist");
            return false;
        }
        if(!isset($args[1]) && !$sender instanceof Player){
            $this->sendUsage($sender, $alias);
            return false;
        }
        $player = $sender;
        if(isset($args[1])){
            if(!$sender->hasPermission("essentials.warp.other")){
                $sender->sendMessage(TextFormat::RED . "[Error] You can't teleport other players to that warp");
                return false;
            }elseif(!($player = $this->getAPI()->getPlayer($args[1]))){
                $sender->sendMessage(TextFormat::RED . "[Error] Player not found");
                return false;
            }
        }
        if(!$sender->hasPermission("essentials.warps.*") && !$sender->hasPermission("essentials.warps.$args[0]")){
            $sender->sendMessage(TextFormat::RED . "[Error] You can't teleport to that warp");
            return false;
        }
        $player->teleport($warp);
        $player->sendMessage(TextFormat::GREEN . "Warping to " . TextFormat::AQUA . $warp->getName() . TextFormat::GREEN . "...");
        if($player !== $sender){
            $sender->sendMessage(TextFormat::GREEN . "Warping " . TextFormat::YELLOW . $player->getDisplayName() . TextFormat::GREEN . " to " . TextFormat::AQUA . $warp->getName() . TextFormat::GREEN . "...");
        }
        return true;
    }
} 
<?php
namespace EssentialsPE\Tasks\Updater;

use EssentialsPE\Loader;
use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;
use pocketmine\utils\TextFormat;
use pocketmine\utils\Utils;

class UpdateFetchTask extends AsyncTask{
    /** @var string */
    private $build;
    /** @var bool */
    private $install;

    /**
     * @param string $build
     * @param bool $install
     */
    public function __construct(string $build, bool $install){
        $this->build = $build;
        $this->install = $install;
    }

    public function onRun(){
        switch($this->build){
            case "stable":
            default:
                $url = "http://forums.pocketmine.net/api.php?action=getResource&value=886"; // PocketMine repository for 'Stable' releases
                $this->build = "stable"; // Override property in case of an 'unknown' source
                break;
            case "beta":
                $url = "https://api.github.com/repos/LegendOfMCPE/EssentialsPE/releases"; // Github repository for 'Beta' releases
                break;
            case "development":
                $url = "https://api.github.com/repos/LegendOfMCPE/EssentialsPE/contents/plugin.yml"; // Github repository for 'Development' versions
                break;
        }
        $i = json_decode(Utils::getURL($url), true);

        $r = [];
        switch(strtolower($this->build)){
            case "stable":
                $r["version"] = $i["version_string"];
                $r["downloadURL"] = "http://forums.pocketmine.net/plugins/essentialspe.886/download?version=" . $i["current_version_id"];
                break;
            case "beta":
                $i = $i[0]; // Grab the latest version from Github releases... Doesn't matter if it's Beta or Stable :3
                $r["version"] = substr($i["name"], 13);
                $r["downloadURL"] = $i["assets"][0]["browser_download_url"];
                break;
            case "development":
                $content = yaml_parse(base64_decode($i["content"]));
                $r["version"] = $content["version"];
                $r["downloadURL"] = "https://github.com/LegendOfMCPE/EssentialsPE/raw/travis-build/EssentialsPE.phar";
                break;
        }
        $this->setResult($r);
    }

    /**
     * @param Server $server
     */
    public function onCompletion(Server $server){
        /** @var Loader $ess */
        $ess = $server->getPluginManager()->getPlugin("EssentialsPE");

        // Tricky move for better "version" comparison...
        $currentVersion = $this->correctVersion($ess->getDescription()->getVersion());
        $v = $this->getResult()["version"];

        if($currentVersion < $v or $this->build === "development"){
            $continue = true;
            $message = TextFormat::AQUA . "[EssentialsPE]" . TextFormat::GREEN .
                ($this->build === "development" ?
                    "Fetching latest EssentialsPE development build..." :
                    " A new " . TextFormat::YELLOW . $this->build . TextFormat::GREEN . " version of EssentialsPE found!"
                ) .
                " Version: " . TextFormat::YELLOW . $v . TextFormat::GREEN .
                ($this->install !== true ? "" : ", " . TextFormat::LIGHT_PURPLE . "Installing...");
        }else{
            $continue = false;
            $message = TextFormat::AQUA . "[EssentialsPE]" . TextFormat::YELLOW . " No new version found, you're using the latest version of EssentialsPE";
        }
        $ess->getAPI()->broadcastUpdateAvailability($message);
        if($continue && $this->install){
            $server->getScheduler()->scheduleAsyncTask($task = new UpdateInstallTask($ess->getAPI(), $this->getResult()["downloadURL"], $server->getPluginPath(), $v));
            $ess->getAPI()->updaterDownloadTask = $task;
        }
    }

    /**
     * @param string $version
     * @return string
     */
    protected function correctVersion(string $version){
        if(($beta = stripos($version, "Beta")) !== false){
            str_replace("Beta", ".", $version);
        }
        $version = explode(".", preg_replace("/[^0-9\.]+/", "", $version));
        $beta = 0;
        if(count($version) > 3){
            $beta = array_pop($version);
            $beta = (count($beta) < 2 ? 0 : "") . $beta;
        }
        return implode("", $version) . "." . $beta;
    }
}<?php
namespace EssentialsPE\Tasks\AFK;

use EssentialsPE\BaseFiles\BaseTask;
use EssentialsPE\BaseFiles\BaseAPI;
use pocketmine\utils\TextFormat;

class AFKSetterTask extends BaseTask{

    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api);
    }

    /*
     * This task is executed every 30 seconds,
     * with the purpose of checking all players' last movement
     * time, stored in their 'Session',
     * and check if it is pretty near,
     * or it's over, the default Idling limit.
     *
     * If so, they will be set in AFK mode
     */

    /**
     * @param int $currentTick
     */
    public function onRun($currentTick){
        $this->getAPI()->getServer()->getLogger()->debug(TextFormat::YELLOW . "Running EssentialsPE's AFKSetterTask");
        foreach($this->getAPI()->getServer()->getOnlinePlayers() as $p){
            if(!$this->getAPI()->isAFK($p) && ($last = $this->getAPI()->getLastPlayerMovement($p)) !== null && !$p->hasPermission("essentials.afk.preventauto")){
                if(time() - $last >= $this->getAPI()->getEssentialsPEPlugin()->getConfig()->getNested("afk.auto-set")){
                    $this->getAPI()->setAFKMode($p, true, $this->getAPI()->getEssentialsPEPlugin()->getConfig()->getNested("afk.auto-broadcast"));
                }
            }
        }
        // Re-Schedule the task xD
        $this->getAPI()->scheduleAutoAFKSetter();
    }
}<?php
namespace EssentialsPE\BaseFiles;

use EssentialsPE\Loader;
use pocketmine\scheduler\PluginTask;

abstract class BaseTask extends PluginTask{
    /** @var BaseAPI */
    private $api;

    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api->getEssentialsPEPlugin());
        $this->api = $api;
    }

    /**
     * @return Loader
     */
    public final function getPlugin(): Loader{
        return $this->getAPI()->getEssentialsPEPlugin();
    }

    /**
     * @return BaseAPI
     */
    public final function getAPI(): BaseAPI{
        return $this->api;
    }
}<?php
namespace EssentialsPE\Events;


use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCustomEvent;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerNickChangeEvent extends BaseCustomEvent implements Cancellable{
    public static $handlerList = null;

    /** @var Player  */
    protected $player;
    /** @var  null|string */
    protected   $new_nick;
    /** @var  string */
    protected   $old_nick;
    /** @var bool|mixed  */
    protected $nametag;

    /**
     * @param BaseAPI $api
     * @param Player $player
     * @param string $new_nick
     * @param mixed $nametag
     */
    public function __construct(BaseAPI $api, Player $player, string $new_nick, $nametag = false){
        parent::__construct($api);
        $this->player = $player;
        $this->new_nick = $new_nick;
        $this->old_nick = $player->getDisplayName();
        $this->nametag = ($nametag ?? $new_nick);
    }

    /**
     * Return the player to be used
     *
     * @return Player
     */
    public function getPlayer(): Player{
        return $this->player;
    }

    /**
     * Return the new nick to be set
     *
     * @return string
     */
    public function getNewNick(): string{
        return $this->new_nick;
    }

    /**
     * Tell the actual nick of the player
     *
     * @return string
     */
    public function getOldNick(): string{
        return $this->old_nick;
    }

    /**
     * Change the nick to be set
     *
     * @param string $nick
     */
    public function setNick(string $nick){
        $this->new_nick = $nick;
    }

    /**
     * Return the NameTag to be set
     * Usually it's the same has the new nick, but plugins can use it to modify the NameTag too
     *
     * @return bool|string
     */
    public function getNameTag(){
        return $this->nametag;
    }

    /**
     * Change the NameTag to be set
     *
     * @param null|string $nametag
     */
    public function setNameTag($nametag){
        $this->nametag = $nametag;
    }
}
<?php
namespace EssentialsPE\BaseFiles;

use EssentialsPE\Loader;
use pocketmine\event\plugin\PluginEvent;

abstract class BaseCustomEvent extends PluginEvent{
    /** @var BaseAPI */
    private $api;

    /**
     * @param BaseAPI $api
     */
    public function __construct(BaseAPI $api){
        parent::__construct($api->getEssentialsPEPlugin());
        $this->api = $api;
    }

    /**
     * @return Loader
     */
    public final function getPlugin(): Loader{
        return $this->getAPI()->getEssentialsPEPlugin();
    }

    /**
     * @return BaseAPI
     */
    public final function getAPI(): BaseAPI{
        return $this->api;
    }
}<?php
namespace EssentialsPE\BaseFiles;

use EssentialsPE\Loader;
use pocketmine\command\CommandSender;
use pocketmine\level\Location;
use pocketmine\Player;
use pocketmine\utils\Config;

class BaseSession{
    /** @var BaseAPI */
    private $api;
    /** @var Player */
    private $player;
    /** @var Config */
    private $config;
    /** @var array */
    public static $defaults = [
        "isAFK" => false,
        "kickAFK" => null,
        "lastMovement" => null,
        "lastPosition" => null,
        "isGod" => false,
        "homes" => [],
        "quickReply" => false,
        "isMuted" => false,
        "mutedUntil" => null,
        "nick" => null,
        "ptCommands" => false,
        "ptChatMacros" => false,
        "isPvPEnabled" => true,
        "requestTo" => false,
        "requestToAction" => false,
        "requestToTask" => null,
        "latestRequestFrom" => null,
        "requestsFrom" => [],
        "isUnlimitedEnabled" => false,
        "isVanished" => false,
        "noPacket" => false
    ];
    /** @var array */
    public static $configDefaults = [
        "isAFK" => false,
        "isGod" => false,
        "homes" => [],
        "isMuted" => false,
        "mutedUntil" => null,
        "nick" => null,
        "ptCommands" => false,
        "ptChatMacros" => false,
        "isPvPEnabled" => true,
        "isUnlimitedEnabled" => false,
        "isVanished" => false
    ];

    /**
     * @param BaseAPI $api
     * @param Player $player
     * @param Config $config
     * @param array $values
     */
    public function __construct(BaseAPI $api, Player $player, Config $config, array $values){
        $this->api = $api;
        $this->player = $player;
        $this->config = $config;
        self::$defaults["lastMovement"] = !$player->hasPermission("essentials.afk.preventauto") ? time() : null;
        foreach($values as $k => $v){
            $this->{$k} = $v;
        }
        $this->loadHomes();
    }

    private function saveSession(){
        $values = [];
        foreach(self::$configDefaults as $k => $v){
            switch($k){
                case "mutedUntil":
                    $v = $this->{$k} instanceof \DateTime ? $this->{$k}->getTimestamp() : null;
                    break;
                case "homes":
                    $v = $this->encodeHomes();
                    break;
                default:
                    $v = $this->{$k};
                    break;
            }
            $values[$k] = $v;
        }
        $this->config->setAll($values);
        $this->config->save(true);
    }

    public function onClose(){
        $this->saveSession();

        // Let's revert some things to their original state...
        $this->setNick(null);
        $this->getAPI()->removeTPRequest($this->getPlayer());
        /*if($this->isVanished()){
            $this->getAPI()->setVanish($this->getPlayer(), false, $this->noPacket());
        }*/
    }

    /**
     * @return Loader
     */
    public final function getPlugin(): Loader{
        return $this->getAPI()->getEssentialsPEPlugin();
    }

    /**
     * @return BaseAPI
     */
    public final function getAPI(): BaseAPI{
        return $this->api;
    }

    /**
     * @return Player
     */
    public final function getPlayer(): Player{
        return $this->player->getPlayer();
    }

    /**
     *            ______ _  __
     *      /\   |  ____| |/ /
     *     /  \  | |__  | ' /
     *    / /\ \ |  __| |  <
     *   / ____ \| |    | . \
     *  /_/    \_|_|    |_|\_\
     */

    /** @var bool */
    private $isAFK = false;
    /** @var int|null */
    private $kickAFK = null;
    /** @var int|null */
    private $lastMovement = null;

    /**
     * @return bool
     */
    public function isAFK(): bool{
        return $this->isAFK;
    }

    /**
     * @param bool $mode
     * @return bool
     */
    public function setAFK(bool $mode): bool{
        $this->isAFK = $mode;
        return true;
    }

    /**
     * @return bool|int
     */
    public function getAFKKickTaskID(){
        if(!$this->isAFK()){
            return false;
        }
        return $this->kickAFK;
    }

    /**
     * @param int $id
     * @return bool
     */
    public function setAFKKickTaskID(int $id): bool{
        $this->kickAFK = $id;
        return true;
    }

    public function removeAFKKickTaskID(){
        $this->kickAFK = null;
    }

    /**
     * @return int|null
     */
    public function getLastMovement(){
        return $this->lastMovement;
    }

    /**
     * @param int $time
     */
    public function setLastMovement(int $time){
        $this->lastMovement = $time;
    }

    /**  ____             _
     *  |  _ \           | |
     *  | |_) | __ _  ___| | __
     *  |  _ < / _` |/ __| |/ /
     *  | |_) | (_| | (__|   <
     *  |____/ \__,_|\___|_|\_\
     */

    /** @var null */
    private $lastLocation = null;

    /**
     * @return bool|Location
     */
    public function getLastPosition(){
        if(!$this->lastLocation instanceof Location){
            return false;
        }
        return $this->lastLocation;
    }

    /**
     * @param Location $pos
     */
    public function setLastPosition(Location $pos){
        $this->lastLocation = $pos;
    }

    public function removeLastPosition(){
        $this->lastLocation = null;
    }

    /**   _____            _                     _   _
     *   / ____|          | |                   | | (_)
     *  | |  __  ___  ___ | |     ___   ___ __ _| |_ _  ___  _ __
     *  | | |_ |/ _ \/ _ \| |    / _ \ / __/ _` | __| |/ _ \| '_ \
     *  | |__| |  __| (_) | |___| (_) | (_| (_| | |_| | (_) | | | |
     *   \_____|\___|\___/|______\___/ \___\__,_|\__|_|\___/|_| |_|
     */

    /** @var null|string */
    private $geoLocation = null;

    /**
     * @return null|string
     */
    public function getGeoLocation(){
        return $this->geoLocation;
    }

    /**
     * @param string $location
     */
    public function setGeoLocation($location){
        $this->geoLocation = $location;
    }

    /**   _____           _
     *   / ____|         | |
     *  | |  __  ___   __| |
     *  | | |_ |/ _ \ / _` |
     *  | |__| | (_) | (_| |
     *   \_____|\___/ \__,_|
     */

    /** @var bool */
    private $isGod = false;

    /**
     * @return bool
     */
    public function isGod(): bool{
        return $this->isGod;
    }

    /**
     * @param bool $mode
     * @return bool
     */
    public function setGod(bool $mode): bool{
        $this->isGod = $mode;
        return true;
    }

    /**  _    _
     *  | |  | |
     *  | |__| | ___  _ __ ___   ___ ___
     *  |  __  |/ _ \| '_ ` _ \ / _ / __|
     *  | |  | | (_) | | | | | |  __\__ \
     *  |_|  |_|\___/|_| |_| |_|\___|___/
     */

    /** @var array */
    private $homes = [];

    private function loadHomes(){
        $homes = [];
        foreach($this->homes as $name => $values){
            if(is_array($values) && count($values) > 1){
                if($this->getPlugin()->getServer()->isLevelGenerated($values[3])){
                    if(!$this->getPlugin()->getServer()->isLevelLoaded($values[3])){
                        $this->getPlugin()->getServer()->loadLevel($values[3]);
                    }
                    $homes[$name] = new BaseLocation($name, $values[0], $values[1], $values[2], $this->getPlugin()->getServer()->getLevelByName($values[3]), $values[4], $values[5]);
                }
            }
        }
        $this->homes = $homes;
    }

    private function encodeHomes(){
        $homes = [];
        foreach($this->homes as $name => $object){
            if($object instanceof BaseLocation){
                $homes[$name] = [$object->getX(), $object->getY(), $object->getZ(), $object->getLevel()->getName(), $object->getYaw(), $object->getPitch()];
            }
        }
        return $homes;
    }

    /**
     * @param string $home
     * @return bool
     */
    public function homeExists(string $home): bool{
        return $this->getAPI()->validateName($home) && isset($this->homes[$home]) && $this->homes[$home] instanceof BaseLocation;
    }

    /**
     * @param string $home
     * @return bool|BaseLocation
     */
    public function getHome(string $home){
        if(!$this->homeExists($home)){
            return false;
        }
        return $this->homes[$home];
    }

    /**
     * @param string $home
     * @param Location $pos
     * @return bool
     */
    public function setHome(string $home, Location $pos): bool{
        if(!$this->getAPI()->validateName($home, false)){
            return false;
        }
        $this->homes[$home] = $pos instanceof BaseLocation ? $pos : BaseLocation::fromPosition($home, $pos);
        return true;
    }

    /**
     * @param string $home
     * @return bool
     */
    public function removeHome(string $home): bool{
        if(!$this->homeExists($home)){
            return false;
        }
        unset($this->homes[$home]);
        return true;
    }

    /**
     * @param bool $inArray
     * @return array|bool|string
     */
    public function homesList(bool $inArray = false){
        $list = array_keys($this->homes);
        if(count($list) < 1){
            return false;
        }
        if(!$inArray){
            return implode(", ", $list);
        }
        return $list;
    }

    /**  __  __
     *  |  \/  |
     *  | \  / |___  __ _
     *  | |\/| / __|/ _` |
     *  | |  | \__ | (_| |
     *  |_|  |_|___/\__, |
     *               __/ |
     *              |___/
     */

    /** @var bool|string */
    private $quickReply = false;

    /**
     * @return bool|string
     */
    public function getQuickReply(){
        return $this->quickReply;
    }

    /**
     * @param CommandSender $sender
     */
    public function setQuickReply(CommandSender $sender){
        $this->quickReply = $sender->getName();
    }

    public function removeQuickReply(){
        $this->quickReply = false;
    }

    /**  __  __       _
     *  |  \/  |     | |
     *  | \  / |_   _| |_ ___
     *  | |\/| | | | | __/ _ \
     *  | |  | | |_| | ||  __/
     *  |_|  |_|\__,_|\__\___|
     */

    /** @var bool */
    private $isMuted = false;
    /** @var \DateTime|null */
    private $mutedUntil = null;

    /**
     * @return bool
     */
    public function isMuted(): bool{
        return $this->isMuted;
    }

    /**
     * @return \DateTime|null
     */
    public function getMutedUntil(){
        return $this->mutedUntil;
    }

    /**
     * @param bool $state
     * @param \DateTime|null $expires
     */
    public function setMuted(bool $state, \DateTime $expires = null){
        $this->isMuted = $state;
        $this->mutedUntil = $expires;
    }

    /**  _   _ _      _
     *  | \ | (_)    | |
     *  |  \| |_  ___| | _____
     *  | . ` | |/ __| |/ / __|
     *  | |\  | | (__|   <\__ \
     *  |_| \_|_|\___|_|\_|___/
     */

    /** @var null|string */
    private $nick = null;

    /**
     * @return null|string
     */
    public function getNick(){
        return $this->nick;
    }

    /**
     * @param null|string $nick
     */
    public function setNick($nick){
        $this->nick = $nick;
        $this->getPlayer()->setDisplayName($nick ?? $this->getPlayer()->getName());
        $this->getPlayer()->setNameTag($nick ?? $this->getPlayer()->getName());
    }

    /**  _____                    _______          _
     *  |  __ \                  |__   __|        | |
     *  | |__) _____      _____ _ __| | ___   ___ | |
     *  |  ___/ _ \ \ /\ / / _ | '__| |/ _ \ / _ \| |
     *  | |  | (_) \ V  V |  __| |  | | (_) | (_) | |
     *  |_|   \___/ \_/\_/ \___|_|  |_|\___/ \___/|_|
     */

    /** @var bool|array */
    private $ptCommands = false;
    /** @var bool|array */
    private $ptChatMacro = false;

    /**
     * @return bool
     */
    public function isPowerToolEnabled(): bool{
        if(!$this->ptCommands && !$this->ptChatMacro){
            return false;
        }
        return true;
    }

    /**
     * @param int $itemId
     * @param string $command
     * @return bool
     */
    public function setPowerToolItemCommand(int $itemId, string $command): bool{
        if($itemId < 1){
            return false;
        }
        if(!is_array($this->ptCommands) || !isset($this->ptCommands[$itemId]) || !is_array($this->ptCommands[$itemId])){
            $this->ptCommands[$itemId] = $command;
        }else{
            $this->ptCommands[$itemId][] = $command;
        }
        return true;
    }

    /**
     * @param int $itemId
     * @return bool|string
     */
    public function getPowerToolItemCommand(int $itemId){
        if($itemId < 1) {
            return false;
        }elseif(!isset($this->ptCommands[$itemId]) || is_array($this->ptCommands[$itemId])){
            return false;
        }elseif($this->ptCommands[$itemId] === null){
            unset($this->ptCommands[$itemId]);
            return false;
        }
        return $this->ptCommands[$itemId];
    }

    /**
     * @param int $itemId
     * @param array $commands
     * @return bool
     */
    public function setPowerToolItemCommands(int $itemId, array $commands): bool{
        if($itemId < 1 || count($commands) < 1){
            return false;
        }
        $this->ptCommands[$itemId] = $commands;
        return true;
    }

    /**
     * @param int $itemId
     * @return bool
     */
    public function getPowerToolItemCommands(int $itemId): bool{
        if($itemId < 1 || !is_array($this->ptCommands) || !isset($this->ptCommands[$itemId]) || !is_array($this->ptCommands[$itemId])){
            return false;
        }elseif($this->ptCommands[$itemId] === null){
            unset($this->ptCommands[$itemId]);
            return false;
        }
        return $this->ptCommands[$itemId];
    }

    /**
     * @param int $itemId
     * @param string $command
     */
    public function removePowerToolItemCommand(int $itemId, string $command){
        $commands = $this->getPowerToolItemCommands($itemId);
        if(is_array($commands)){
            foreach($commands as $c){
                if(stripos(strtolower($c), strtolower($command)) !== false){
                    unset($c);
                }
            }
        }
    }

    /**
     * @param int $itemId
     * @param string $chat_message
     * @return bool
     */
    public function setPowerToolItemChatMacro(int $itemId, string $chat_message): bool{
        if($itemId < 1){
            return false;
        }
        $chat_message = str_replace("\\n", "\n", $chat_message);
        $this->ptChatMacro[$itemId] = $chat_message;
        return true;
    }

    /**
     * @param int $itemId
     * @return bool
     */
    public function getPowerToolItemChatMacro(int $itemId): bool{
        if($itemId < 1 || !isset($this->ptChatMacro[$itemId])){
            return false;
        }
        return $this->ptChatMacro[$itemId];
    }

    /**
     * @param int $itemId
     */
    public function disablePowerToolItem(int $itemId){
        unset($this->ptCommands[$itemId]);
        unset($this->ptChatMacro[$itemId]);
    }

    public function disablePowerTool(){
        $this->ptCommands = false;
        $this->ptChatMacro = false;
    }

    /**  _____        _____
     *  |  __ \      |  __ \
     *  | |__) __   _| |__) |
     *  |  ___/\ \ / |  ___/
     *  | |     \ V /| |
     *  |_|      \_/ |_|
     */

    /** @var bool */
    private $isPvPEnabled = true;

    /**
     * @return bool
     */
    public function isPVPEnabled(): bool{
        return $this->isPvPEnabled;
    }

    /**
     * @param bool $mode
     * @return bool
     */
    public function setPvP(bool $mode): bool{
        $this->isPvPEnabled = $mode;
        return true;
    }

    /**  _______ _____  _____                           _
     *  |__   __|  __ \|  __ \                         | |
     *     | |  | |__) | |__) |___  __ _ _   _  ___ ___| |_ ___
     *     | |  |  ___/|  _  // _ \/ _` | | | |/ _ / __| __/ __|
     *     | |  | |    | | \ |  __| (_| | |_| |  __\__ | |_\__ \
     *     |_|  |_|    |_|  \_\___|\__, |\__,_|\___|___/\__|___/
     *                                | |
     *                                |_|
     */

    //Request to:
    /** @var bool|string */
    private $requestTo = false;
    /** @var bool|string */
    private $requestToAction = false;
    /** @var null|int */
    private $requestToTask = null;

    /**
     * @return array|bool
     */
    public function madeARequest(){
        return ($this->requestTo !== false ? [$this->requestTo, $this->requestToAction] : false);
    }

    /**
     * @param string $target
     * @return bool
     */
    public function madeARequestTo(string $target): bool{
        return $this->requestTo === $target;
    }

    /**
     * @param string $target
     * @param string $action
     */
    public function requestTP(string $target, string $action){
        $this->requestTo = $target;
        $this->requestToAction = $action;
    }

    public function cancelTPRequest(){
        $this->requestTo = false;
        $this->requestToAction = false;
    }

    /**
     * @return bool|int
     */
    public function getRequestToTaskID(){
        return ($this->requestToTask !== null ? $this->requestToTask : false);
    }

    /**
     * @param int $taskId
     * @return bool
     */
    public function setRequestToTaskID(int $taskId): bool{
        $this->requestToTask = $taskId;
        return true;
    }

    public function removeRequestToTaskID(){
        $this->requestToTask = null;
    }

    //Requests from:
    /** @var null|string */
    private $latestRequestFrom = null;
    /** @var array */
    private $requestsFrom = [];
    /** This is how it works per player:
    *
    * "iksaku" => "tpto"  <--- Type of request
    *    ^^^
    * Requester Name
    */

    /**
     * @return array|bool
     */
    public function hasARequest(){
        return (count($this->requestsFrom) > 0 ? $this->requestsFrom : false);
    }

    /**
     * @param string $requester
     * @return bool|string
     */
    public function hasARequestFrom(string $requester){
        return (isset($this->requestsFrom[$requester]) ? $this->requestsFrom[$requester] : false);
    }

    /**
     * @return bool|string
     */
    public function getLatestRequestFrom(){
        return ($this->latestRequestFrom !== null ? $this->latestRequestFrom : false);
    }

    /**
     * @param string $requester
     * @param string $action
     */
    public function receiveRequest(string $requester, string $action){
        $this->latestRequestFrom = $requester;
        $this->requestsFrom[$requester] = $action;
    }

    /**
     * @param string $requester
     */
    public function removeRequestFrom(string $requester){
        unset($this->requestsFrom[$requester]);
        if($this->getLatestRequestFrom() === $requester){
            $this->latestRequestFrom = null;
        }
    }

    /**  _    _       _ _           _ _           _   _____ _
     *  | |  | |     | (_)         (_| |         | | |_   _| |
     *  | |  | |_ __ | |_ _ __ ___  _| |_ ___  __| |   | | | |_ ___ _ __ ___  ___
     *  | |  | | '_ \| | | '_ ` _ \| | __/ _ \/ _` |   | | | __/ _ | '_ ` _ \/ __|
     *  | |__| | | | | | | | | | | | | ||  __| (_| |  _| |_| ||  __| | | | | \__ \
     *   \____/|_| |_|_|_|_| |_| |_|_|\__\___|\__,_| |_____|\__\___|_| |_| |_|___/
     */

    /** @var bool */
    private $isUnlimitedEnabled = false;

    /**
     * @return bool
     */
    public function isUnlimitedEnabled(): bool{
        return $this->isUnlimitedEnabled;
    }

    /**
     * @param bool $mode
     * @return bool
     */
    public function setUnlimited(bool $mode): bool{
        $this->isUnlimitedEnabled = $mode;
        return true;
    }

    /** __      __         _     _
     *  \ \    / /        (_)   | |
     *   \ \  / __ _ _ __  _ ___| |__
     *    \ \/ / _` | '_ \| / __| '_ \
     *     \  | (_| | | | | \__ | | | |
     *      \/ \__,_|_| |_|_|___|_| |_|
     */

    /** @var bool */
    private $isVanished = false;

    /**
     * If set to true, we will use Player packets instead of Effect ones
     *
     * @var bool
     */
    private $noPacket = false;

    /**
     * @return bool
     */
    public function isVanished(): bool{
        return $this->isVanished;
    }

    /**
     * @param bool $mode
     * @param bool $noPacket
     * @return bool
     */
    public function setVanish(bool $mode, bool $noPacket): bool{
        $this->isVanished = $mode;
        $this->noPacket = $noPacket;
        return true;
    }

    /**
     * @return bool
     */
    public function noPacket(): bool{
        return $this->noPacket;
    }
}
<?php
namespace EssentialsPE\Events;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCustomEvent;
use pocketmine\Player;

class SessionCreateEvent extends BaseCustomEvent{
    public static $handlerList = null;

    /** @var Player  */
    public $player;
    /** @var array  */
    public $values;

    /**
     * @param BaseAPI $api
     * @param Player $player
     * @param array $values
     */
    public function __construct(BaseAPI $api, Player $player, array $values){
        parent::__construct($api);
        $this->player = $player;
        $this->values = $values;
    }

    /**
     * return the Player to work on
     *
     * @return Player
     */
    public function getPlayer(): Player{
        return $this->player;
    }

    /**
     * Return all the Session Values
     *
     * @return array
     */
    public function getValues(): array{
        return $this->values;
    }

    /**
     * Replace a specific Session Value
     *
     * @param string $key
     * @param mixed $value
     */
    public function setValue(string $key, mixed $value){
        if(!isset($this->values[$key])){
            return;
        }
        $this->values[$key] = $value;
    }

    /**
     * Set the Session Values
     *
     * @param array $values
     */
    public function setValues(array $values){
        $this->values = $values;
    }
} <?php
namespace EssentialsPE\Tasks;

use EssentialsPE\Loader;
use pocketmine\Player;
use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;
use pocketmine\utils\Utils;

class GeoLocation extends AsyncTask{
    /** @var Player[]|null */
    private $player = null;
    /** @var array */
    private $ip = [];

    /**
     * @param Player|Player[]|null $player
     */
    public function __construct($player){
        if($player !== null){
            if(!is_array($player)){
                $player = [$player];
            }
            foreach($player as $p){
                $spl = spl_object_hash($p);
                $this->player[$spl] = $p;
                $this->ip[$spl] = $p->getAddress();
            }
        }
    }

    public function onRun(){
        if($this->player === null){
            $data = Utils::getURL("http://ip-api.com/json/");
            $this->setResult(json_decode($data, true)["country"] ?? "Unknown");
        }else{
            $list = [];
            foreach($this->ip as $spl => $ip){
                $data = Utils::getURL("http://ip-api.com/json/" . $ip);
                $data = json_decode($data, true);
                if(isset($data["message"]) && $data["message"] === "private range"){
                    $data["country"] = "server";
                }
                if(isset($data["country"])){
                    $list[$spl] = $data["country"] ?? "Unknown";
                }
            }
            $this->setResult($list);
        }
    }

    /**
     * @param Server $server
     */
    public function onCompletion(Server $server){
        /** @var Loader $plugin */
        $plugin = $server->getPluginManager()->getPlugin("EssentialsPE");
        if(!is_array($this->getResult())){
            $plugin->getAPI()->setServerGeoLocation($this->getResult());
        }else{
            foreach($this->getResult() as $spl => $loc){
                $plugin->getAPI()->updateGeoLocation($this->player[$spl], ($loc !== "server" ?? $plugin->getAPI()->getServerGeoLocation()));
            }
        }
    }
}<?php
namespace EssentialsPE\Events;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCustomEvent;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerAFKModeChangeEvent extends BaseCustomEvent implements Cancellable{
    public static $handlerList = null;

    /** @var Player */
    protected $player;
    /** @var bool */
    protected $isAFK;
    /** @var bool */
    protected $mode;
    /** @var bool */
    protected $broadcast;

    /**
     * @param BaseAPI $api
     * @param Player $player
     * @param bool $mode
     * @param bool $broadcast
     */
    public function __construct(BaseAPI $api, Player $player, bool $mode, bool $broadcast){
        parent::__construct($api);
        $this->player = $player;
        $this->isAFK = $api->isAFK($player);
        $this->mode = $mode;
        $this->broadcast = $broadcast;
    }

    /**
     * Return the player to be used
     *
     * @return Player
     */
    public function getPlayer(): Player{
        return $this->player;
    }

    /**
     * Tell if the player is already AFK or not
     *
     * @return bool
     */
    public function isAFK(): bool{
        return $this->isAFK;
    }

    /**
     * Tell the mode will to be set
     *
     * @return bool
     */
    public function getAFKMode(): bool{
        return $this->mode;
    }

    /**
     * Change the mode to be set
     * false = Player will not be AFK
     * true = Player will be AFK
     *
     * @param bool $mode
     */
    public function setAFKMode(bool $mode){
        $this->mode = $mode;
    }

    /**
     * Tell if the AFK status will be broadcast
     *
     * @return bool
     */
    public function getBroadcast(): bool{
        return $this->broadcast;
    }

    /**
     * Specify if the AFK status will be broadcast
     *
     * @param bool $mode
     */
    public function setBroadcast(bool $mode){
        $this->broadcast = $mode;
    }
} <?php
namespace EssentialsPE\Events;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCustomEvent;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerFlyModeChangeEvent extends BaseCustomEvent implements Cancellable{
    public static $handlerList = null;

    /** @var Player */
    protected $player;
    /** @var bool */
    protected $isFlying;
    /** @var bool */
    protected $mode;

    /**
     * @param BaseAPI $api
     * @param Player $player
     * @param bool $mode
     */
    public function __construct(BaseAPI $api, Player $player, bool $mode){
        parent::__construct($api);
        $this->player = $player;
        $this->isFlying = $api->canFly($player);
        $this->mode = $mode;
    }

    /**
     * The player to work over
     *
     * @return Player
     */
    public function getPlayer(): Player{
        return $this->player;
    }

    /**
     * The current "flying" status of the player
     *
     * @return bool
     */
    public function getCanFly(): bool{
        return $this->isFlying;
    }

    /**
     * The "flying" status to set
     *
     * @return bool
     */
    public function willFly(): bool{
        return $this->mode;
    }

    /**
     * Modify the "flying" status to be set
     *
     * @param bool $mode
     */
    public function setCanFly(bool $mode){
        $this->mode = $mode;
    }
}<?php
namespace EssentialsPE\Tasks;

use EssentialsPE\BaseFiles\BaseTask;
use EssentialsPE\BaseFiles\BaseAPI;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TPRequestTask extends BaseTask{
    /** @var Player  */
    protected $requester;

    /**
     * @param BaseAPI $api
     * @param Player $requester
     */
    public function __construct(BaseAPI $api, Player $requester){
        parent::__construct($api);
        $this->requester = $requester;
    }

    /**
     * @param int $currentTick
     */
    public function onRun($currentTick){
        if($this->requester instanceof Player && $this->requester->isOnline()) {
            $this->getAPI()->getServer()->getLogger()->debug(TextFormat::YELLOW . "Running EssentialsPE's TPRequestTask");
            $this->getAPI()->removeTPRequest($this->requester);
        }
    }
} <?php
namespace EssentialsPE\Tasks\AFK;

use EssentialsPE\BaseFiles\BaseTask;
use EssentialsPE\BaseFiles\BaseAPI;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AFKKickTask extends BaseTask{
    /** @var Player  */
    protected $player;

    /**
     * @param BaseAPI $api
     * @param Player $player
     */
    public function __construct(BaseAPI $api, Player $player){
        parent::__construct($api);
        $this->player = $player;
    }

    /**
     * @param int $currentTick
     */
    public function onRun($currentTick){
        // TODO: Remember access to API for tasks...
        $this->getAPI()->getServer()->getLogger()->debug(TextFormat::YELLOW . "Running EssentialsPE's AFKKickTask");
        if($this->player instanceof Player && $this->player->isOnline() && $this->getAPI()->isAFK($this->player) && !$this->player->hasPermission("essentials.afk.kickexempt") && time() - $this->getAPI()->getLastPlayerMovement($this->player) >= $this->getAPI()->getEssentialsPEPlugin()->getConfig()->getNested("afk.auto-set")){
            $this->player->kick("You have been kicked for idling more than " . (($time = floor($this->getAPI()->getEssentialsPEPlugin()->getConfig()->getNested("afk.auto-kick"))) / 60 >= 1 ? ($time / 60) . " minutes" : $time . " seconds"), false);
        }
    }
} <?php
namespace EssentialsPE\Events;

use EssentialsPE\BaseFiles\BaseAPI;
use EssentialsPE\BaseFiles\BaseCustomEvent;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerMuteEvent extends BaseCustomEvent implements Cancellable{
    public static $handlerList = null;

    /** @var Player  */
    protected $player;
    /** @var  bool */
    protected $isMuted;
    /** @var  bool */
    protected $mode;
    /** @var \DateTime|null */
    protected $expires;

    /**
     * @param BaseAPI $api
     * @param Player $player
     * @param bool $mode
     * @param \DateTime $expires
     */
    public function __construct(BaseAPI $api, Player $player, bool $mode, \DateTime $expires = null){
        parent::__construct($api);
        $this->player = $player;
        $this->isMuted = $api->isMuted($player);
        $this->mode = $mode;
        $this->expires = $expires;
    }

    /**
     * Return the player to be used
     *
     * @return Player
     */
    public function getPlayer(): Player{
        return $this->player;
    }

    /**
     * Tell is the player is already muted
     *
     * @return bool
     */
    public function isMuted(): bool{
        return $this->isMuted;
    }

    /**
     * Tell if the player will be muted or not
     *
     * @return bool
     */
    public function willMute(): bool{
        return $this->mode;
    }

    /**
     * Change the Mute mode to be set
     * false = Player will not be muted
     * true = Player will be muted
     *
     * @param bool $mode
     */
    public function setMuted(bool $mode){
        $this->mode = $mode;
    }

    /**
     * Tells the time the mute state will stay
     * int = "Date Time format" of expiration
     * null = Will keep forever
     *
     * @return \DateTime|null
     */
    public function getMutedUntil(){
        return $this->expires;
    }

    /**
     * Set how long the mute will be applied
     * int = "Date Time format" of expiration
     * null = Will keep forever
     *
     * @param \DateTime|null $expires
     */
    public function setMutedUntil(\DateTime $expires = null){
        $this->expires = $expires;
    }
} 